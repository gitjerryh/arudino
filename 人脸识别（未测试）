#include <HUSKYLENS.h>
#include <Wire.h>
#include <ESP32Servo.h>
#include "esp_task_wdt.h"

HUSKYLENS huskylens;
Servo panServo;
Servo tiltServo;

// 硬件引脚定义
const int PAN_SERVO_PIN = 12;
const int TILT_SERVO_PIN = 13;
const int RELAY_PIN = 5;
const int STATUS_LED_PIN = 2;

// 系统参数
const int FRAME_WIDTH = 320;
const int FRAME_HEIGHT = 240;
const int FRAME_CENTER_X = FRAME_WIDTH / 2;
const int FRAME_CENTER_Y = FRAME_HEIGHT / 2;
const int KNOWN_FACE_ID = 1;
const int RELAY_DELAY = 5000;
const int DEBOUNCE_DELAY = 500;
const int ALGORITHM_SWITCH_DELAY = 1000; // 算法切换延时

// 工作模式枚举
enum WorkMode {
    FACE_RECOGNITION,
    OBJECT_TRACKING,
    UNKNOWN
} currentMode = UNKNOWN;



// PID控制器结构体
struct PIDController {
    float Kp = 0.15;
    float Ki = 0.004;
    float Kd = 0.08;
    float integral = 0;
    float previousError = 0;
    float integralLimit = 50.0;
};

PIDController panPID;
PIDController tiltPID;

// 跟踪相关变量
float currentPanPosition = 90;
float currentTiltPosition = 90;
bool relayState = false;
unsigned long lastTriggerTime = 0;
unsigned long lastSuccessfulRequest = 0;
unsigned long lastAlgorithmSwitch = 0;

// 位置历史记录
const int POSITION_HISTORY_SIZE = 6;
struct PositionHistory {
    int x[POSITION_HISTORY_SIZE];
    int y[POSITION_HISTORY_SIZE];
    unsigned long timestamp[POSITION_HISTORY_SIZE];
    int index = 0;
} posHistory;

// 跟踪状态控制
enum TrackingState {
    IDLE,
    TRACKING,
    PREDICTING,
    RETURNING
} trackingState = IDLE;

// 速度控制参数
const float MAX_SPEED = 3.0;
const float MAX_ACCELERATION = 0.4;
float lastPanSpeed = 0;
float lastTiltSpeed = 0;

// 函数声明
void blinkStatusLED(int times);
void centerGimbal();
void initializePositionHistory();
bool ensureConnection();
void checkCurrentAlgorithm();
void executeFaceRecognition();
void executeObjectTracking();
void resetSystem();
void controlRelay(bool state);
void handleLostTarget(unsigned long currentTime);
void predictNextPosition(float &predX, float &predY);
void moveGimbal(float targetX, float targetY);
void resetControllers();
bool isValidCoordinate(int x, int y);
void updatePositionHistory(int x, int y);
bool switchAlgorithm(protocolAlgorithm algorithm);

// 功能初始化
void setup() {
    Serial.begin(115200);
    Wire.begin();
    
    // 初始化引脚
    pinMode(STATUS_LED_PIN, OUTPUT);
    pinMode(RELAY_PIN, OUTPUT);
    digitalWrite(RELAY_PIN, LOW);
    
    // 初始化舵机
    ESP32PWM::allocateTimer(0);
    ESP32PWM::allocateTimer(1);
    panServo.setPeriodHertz(50);
    tiltServo.setPeriodHertz(50);
    panServo.attach(PAN_SERVO_PIN, 500, 2500);
    tiltServo.attach(TILT_SERVO_PIN, 500, 2500);
    
    // 初始化HuskyLens
    while (!huskylens.begin(Wire)) {
        Serial.println(F("连接HuskyLens失败!"));
        blinkStatusLED(3);
        delay(100);
    }
    
    // 初始化完成指示
    digitalWrite(STATUS_LED_PIN, HIGH);
    delay(1000);
    digitalWrite(STATUS_LED_PIN, LOW);
    
    // 默认设置为人脸识别模式
    if (switchAlgorithm(ALGORITHM_FACE_RECOGNITION)) {
        currentMode = FACE_RECOGNITION;
    } else {
        currentMode = UNKNOWN;
    }
    
    centerGimbal();
    initializePositionHistory();
}

// 主循环
void loop() {
    if (!ensureConnection()) {
        Serial.println("连接丢失，尝试重新连接...");
        delay(100);
        return;
    }

    // 检测当前算法模式
    checkCurrentAlgorithm();
    
    // 根据不同模式执行相应功能
    switch (currentMode) {
        case FACE_RECOGNITION:
            executeFaceRecognition();
            break;
            
        case OBJECT_TRACKING:
            executeObjectTracking();
            break;
            
        case UNKNOWN:
            Serial.println("未知模式");
            blinkStatusLED(2);
            break;
    }
    
    delay(20);
}

// 切换算法的辅助函数
bool switchAlgorithm(protocolAlgorithm algorithm) {
    if (millis() - lastAlgorithmSwitch < ALGORITHM_SWITCH_DELAY) {
        return false;
    }
    
    if (!huskylens.writeAlgorithm(algorithm)) {
        Serial.println("切换算法失败");
        return false;
    }
    
    delay(ALGORITHM_SWITCH_DELAY);
    lastAlgorithmSwitch = millis();
    return true;
}

// 检测当前算法模式
void checkCurrentAlgorithm() {
    static WorkMode lastMode = UNKNOWN;
    static unsigned long lastCheck = 0;
    
    // 限制检查频率
    if (millis() - lastCheck < 500) return;
    lastCheck = millis();

    if (!huskylens.request()) return;
    
    if (huskylens.available()) {
        bool hasFaces = false;
        bool hasObjects = false;
        
        // 检查所有返回的结果
        while (huskylens.available()) {
            HUSKYLENSResult result = huskylens.read();
            
            // 根据返回的block类型判断当前模式
            if (result.command == COMMAND_RETURN_BLOCK) {
                if (result.ID > 0) {  // 已学习的目标
                    hasFaces = true;
                } else {  // 未学习的目标
                    hasObjects = true;
                }
            }
        }
        
        // 根据检测结果更新模式
        WorkMode newMode = UNKNOWN;
        if (hasFaces) {
            newMode = FACE_RECOGNITION;
        } else if (hasObjects) {
            newMode = OBJECT_TRACKING;
        }
        
        // 如果模式发生变化，进行切换
        if (newMode != lastMode && newMode != UNKNOWN) {
    protocolAlgorithm algorithm = (newMode == FACE_RECOGNITION) ? 
                                 ALGORITHM_FACE_RECOGNITION : 
                                 ALGORITHM_OBJECT_TRACKING;
                          
    if (switchAlgorithm(algorithm)) {
        currentMode = newMode;
        lastMode = newMode;
        resetSystem();
    }
}
    }
}

// 执行人脸识别模式
void executeFaceRecognition() {
    if (!huskylens.request()) return;
    
    if (huskylens.available()) {
        bool foundKnownFace = false;
        
        while (huskylens.available()) {
            HUSKYLENSResult result = huskylens.read();
            if (result.ID == KNOWN_FACE_ID) {
                foundKnownFace = true;
                break;
            }
        }
        
        if (foundKnownFace) {
            unsigned long currentTime = millis();
            if (currentTime - lastTriggerTime > DEBOUNCE_DELAY) {
                controlRelay(true);
                lastTriggerTime = currentTime;
                delay(RELAY_DELAY);
                controlRelay(false);
            }
        }
    }
}

// 执行物体追踪模式
void executeObjectTracking() {
    if (!huskylens.request()) return;
    
    unsigned long currentTime = millis();
    bool targetFound = false;
    
    if (huskylens.available()) {
        HUSKYLENSResult result = huskylens.read();
        
        if (result.command == COMMAND_RETURN_BLOCK && 
            isValidCoordinate(result.xCenter, result.yCenter)) {
            targetFound = true;
            trackingState = TRACKING;
            updatePositionHistory(result.xCenter, result.yCenter);
            moveGimbal(result.xCenter, result.yCenter);
        }
    }
    
    if (!targetFound) {
        handleLostTarget(currentTime);
    }
}

// 系统重置
void resetSystem() {
    resetControllers();
    centerGimbal();
    digitalWrite(RELAY_PIN, LOW);
    relayState = false;
}

// 其他辅助函数
void initializePositionHistory() {
    unsigned long currentTime = millis();
    for (int i = 0; i < POSITION_HISTORY_SIZE; i++) {
        posHistory.x[i] = FRAME_CENTER_X;
        posHistory.y[i] = FRAME_CENTER_Y;
        posHistory.timestamp[i] = currentTime;
    }
}

bool isValidCoordinate(int x, int y) {
    return (x >= 0 && x <= FRAME_WIDTH && y >= 0 && y <= FRAME_HEIGHT);
}

void handleLostTarget(unsigned long currentTime) {
    if (trackingState == TRACKING) {
        trackingState = PREDICTING;
        float predX, predY;
        predictNextPosition(predX, predY);
        moveGimbal(predX, predY);
    } 
    else if (currentTime - lastTriggerTime > 1500) {
        centerGimbal();
        trackingState = IDLE;
    }
}

// [之前的其他函数保持不变]
void blinkStatusLED(int times) {
    for(int i = 0; i < times; i++) {
        digitalWrite(STATUS_LED_PIN, HIGH);
        delay(200);
        digitalWrite(STATUS_LED_PIN, LOW);
        delay(200);
    }
}

void controlRelay(bool state) {
    if (relayState != state) {
        relayState = state;
        digitalWrite(RELAY_PIN, state ? HIGH : LOW);
    }
}

bool ensureConnection() {
    static uint8_t retryCount = 0;
    if (!huskylens.request() || (millis() - lastSuccessfulRequest > 2000)) {
        if (retryCount < 3) {
            Wire.begin();
            if (huskylens.begin(Wire)) {
                huskylens.writeAlgorithm(ALGORITHM_OBJECT_TRACKING);
                lastSuccessfulRequest = millis();
                retryCount = 0;
                return true;
            }
            retryCount++;
            delay(100);
        } else {
            retryCount = 0;
            return false;
        }
    }
    return true;
}

// 初始化位置历史记录


// 计算PID输出
float calculatePID(PIDController &pid, float error, float dt) {
    if (abs(error) < 10) {
        pid.integral *= 0.93;
        return 0;
    }
    
    float error_sign = error > 0 ? 1.0 : -1.0;
    float error_mag = abs(error);
    
    if (error_mag < 30) {
        pid.integral = constrain(pid.integral + error * dt, -pid.integralLimit, pid.integralLimit);
    } else {
        pid.integral *= 0.95;
    }
    
    float derivative = (error - pid.previousError) / dt;
    derivative = 0.85 * derivative + 0.15 * pid.previousError;
    
    float output = (pid.Kp * error) + (pid.Ki * pid.integral) + (pid.Kd * derivative);
    output = pow(abs(output), 0.8) * (output > 0 ? 1 : -1);
    
    pid.previousError = error;
    return output;
}

// 更新位置历史记录
void updatePositionHistory(int x, int y) {
    posHistory.index = (posHistory.index + 1) % POSITION_HISTORY_SIZE;
    posHistory.x[posHistory.index] = x;
    posHistory.y[posHistory.index] = y;
    posHistory.timestamp[posHistory.index] = millis();
}

// 预测下一个位置
void predictNextPosition(float &predX, float &predY) {
    int latest_idx = posHistory.index;
    int oldest_idx = (latest_idx + 1) % POSITION_HISTORY_SIZE;
    
    float dt = (posHistory.timestamp[latest_idx] - posHistory.timestamp[oldest_idx]) / 1000.0;
    if (dt > 0) {
        float dx = posHistory.x[latest_idx] - posHistory.x[oldest_idx];
        float dy = posHistory.y[latest_idx] - posHistory.y[oldest_idx];
        
        predX = posHistory.x[latest_idx] + dx * 0.1;
        predY = posHistory.y[latest_idx] + dy * 0.1;
    } else {
        predX = posHistory.x[latest_idx];
        predY = posHistory.y[latest_idx];
    }
}

// 移动云台
void moveGimbal(float targetX, float targetY) {
    float dt = 0.02;
    
    float panError = targetX - FRAME_CENTER_X;
    float tiltError = targetY - FRAME_CENTER_Y;
    
    float panAdjustment = calculatePID(panPID, panError, dt);
    float tiltAdjustment = calculatePID(tiltPID, tiltError, dt);
    
    float desiredPanSpeed = -panAdjustment * 0.12;
    float desiredTiltSpeed = tiltAdjustment * 0.12;
    
    desiredPanSpeed = constrain(desiredPanSpeed, 
                              lastPanSpeed - MAX_ACCELERATION, 
                              lastPanSpeed + MAX_ACCELERATION);
    desiredTiltSpeed = constrain(desiredTiltSpeed, 
                               lastTiltSpeed - MAX_ACCELERATION, 
                               lastTiltSpeed + MAX_ACCELERATION);
    
    desiredPanSpeed = constrain(desiredPanSpeed, -MAX_SPEED, MAX_SPEED);
    desiredTiltSpeed = constrain(desiredTiltSpeed, -MAX_SPEED, MAX_SPEED);
    
    float smoothingFactor = 0.45;
    currentPanPosition = currentPanPosition * (1 - smoothingFactor) + 
                        constrain(currentPanPosition + desiredPanSpeed, 0, 180) * smoothingFactor;
    currentTiltPosition = currentTiltPosition * (1 - smoothingFactor) + 
                         constrain(currentTiltPosition + desiredTiltSpeed, 0, 180) * smoothingFactor;
    
    lastPanSpeed = desiredPanSpeed;
    lastTiltSpeed = desiredTiltSpeed;
    
    panServo.write(round(currentPanPosition));
    tiltServo.write(round(currentTiltPosition));
}

// 重置控制器
void resetControllers() {
    panPID.integral = 0;
    tiltPID.integral = 0;
    panPID.previousError = 0;
    tiltPID.previousError = 0;
    lastPanSpeed = 0;
    lastTiltSpeed = 0;
}

// 中心化云台
void centerGimbal() {
    trackingState = IDLE;
    float smoothingFactor = 0.1;
    while (abs(currentPanPosition - 90) > 0.5 || abs(currentTiltPosition - 90) > 0.5) {
        currentPanPosition = currentPanPosition * (1 - smoothingFactor) + 90 * smoothingFactor;
        currentTiltPosition = currentTiltPosition * (1 - smoothingFactor) + 90 * smoothingFactor;
        panServo.write(round(currentPanPosition));
        tiltServo.write(round(currentTiltPosition));
        delay(20);
    }
}
