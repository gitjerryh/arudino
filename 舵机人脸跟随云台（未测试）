#include <HUSKYLENS.h>
#include <Wire.h>
#include <ESP32Servo.h>

HUSKYLENS huskylens;
Servo panServo;  // Horizontal movement
Servo tiltServo; // Vertical movement

// Servo pins
const int PAN_SERVO_PIN = 12;  // Adjust pin numbers as needed
const int TILT_SERVO_PIN = 13; // Adjust pin numbers as needed

// Servo parameters
const int PAN_CENTER = 90;
const int TILT_CENTER = 90;
const int SERVO_MIN = 0;
const int SERVO_MAX = 180;

// PID control parameters
struct PIDController {
    float Kp = 0.3;  // Proportional gain
    float Ki = 0.0;  // Integral gain
    float Kd = 0.1;  // Derivative gain
    float integral = 0;
    float previousError = 0;
};

PIDController panPID;
PIDController tiltPID;

// Camera frame parameters
const int FRAME_WIDTH = 320;
const int FRAME_HEIGHT = 240;
const int FRAME_CENTER_X = FRAME_WIDTH / 2;
const int FRAME_CENTER_Y = FRAME_HEIGHT / 2;

// Current servo positions
int currentPanPosition = PAN_CENTER;
int currentTiltPosition = TILT_CENTER;

void setup() {
    Serial.begin(115200);
    Wire.begin();
    
    // Initialize HUSKYLENS
    while (!huskylens.begin(Wire)) {
        Serial.println(F("HUSKYLENS not connected!"));
        delay(100);
    }
    huskylens.writeAlgorithm(ALGORITHM_FACE_RECOGNITION);

    // Initialize servos
    ESP32PWM::allocateTimer(0);
    ESP32PWM::allocateTimer(1);
    panServo.setPeriodHertz(50);  // Standard 50Hz servo
    tiltServo.setPeriodHertz(50);
    
    panServo.attach(PAN_SERVO_PIN, 500, 2500);   // Adjust min/max pulses if needed
    tiltServo.attach(TILT_SERVO_PIN, 500, 2500);
    
    // Center the gimbal
    panServo.write(PAN_CENTER);
    tiltServo.write(TILT_CENTER);
    delay(1000);
}

float calculatePID(PIDController &pid, float error, float dt) {
    pid.integral += error * dt;
    float derivative = (error - pid.previousError) / dt;
    float output = (pid.Kp * error) + (pid.Ki * pid.integral) + (pid.Kd * derivative);
    pid.previousError = error;
    return output;
}

void moveGimbal(int targetX, int targetY) {
    float dt = 0.02; // 20ms control loop
    
    // Calculate errors (distance from center)
    float panError = targetX - FRAME_CENTER_X;
    float tiltError = targetY - FRAME_CENTER_Y;
    
    // Calculate PID outputs
    float panAdjustment = calculatePID(panPID, panError, dt);
    float tiltAdjustment = calculatePID(tiltPID, tiltError, dt);
    
    // Update servo positions
    currentPanPosition = constrain(currentPanPosition - panAdjustment * 0.1, SERVO_MIN, SERVO_MAX);
    currentTiltPosition = constrain(currentTiltPosition + tiltAdjustment * 0.1, SERVO_MIN, SERVO_MAX);
    
    panServo.write(currentPanPosition);
    tiltServo.write(currentTiltPosition);
}

void loop() {
    if (!huskylens.request()) return;
    
    if (huskylens.countBlocks() > 0) {
        HUSKYLENSResult result = huskylens.getBlock(0); // Get the first detected face
        
        if (result.ID == 1) { // Track only the learned face with ID 1
            Serial.printf("Face detected - X: %d, Y: %d\n", result.xCenter, result.yCenter);
            moveGimbal(result.xCenter, result.yCenter);
        }
    }
    
    delay(20); // 50Hz control loop
}
