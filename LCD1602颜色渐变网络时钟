#include <Wire.h>
#include "GravityRtc.h"
#include "DFRobot_RGBLCD1602.h"
#include "DFRobot_EnvironmentalSensor.h"

GravityRtc rtc;
DFRobot_RGBLCD1602 lcd(0x2D, 16, 2);
DFRobot_EnvironmentalSensor environment(SEN050X_DEFAULT_DEVICE_ADDRESS, &Wire);

const char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
const char* dayNames[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

unsigned long lastUpdate = 0;
unsigned long lastColorChange = 0;
unsigned long lastEnvUpdate = 0;
unsigned long colorDuration = 0;
unsigned long specialEffectStart = 0;
const unsigned long ENV_UPDATE_INTERVAL = 1000;
bool showTimeMode = true;

int currentColor = 0;
float breatheValue = 0;
bool breatheIncreasing = true;
bool inSpecialEffect = false;
int specialEffectStep = 0;

// Custom characters
byte clockChar[8] = {
  B00000, B01110, B10101, B10111,
  B10001, B01110, B00000, B00000
};

byte thermometer[8] = {
  B00100, B01010, B01010, B01110,
  B01110, B11111, B11111, B01110
};

byte humidityChar[8] = {
  B00100, B00100, B01110, B01110,
  B11111, B11111, B01110, B00000
};

byte lightChar[8] = {
  B00000, B10101, B01110, B11111,
  B01110, B10101, B00000, B00000
};

// Color themes
const int MORNING_COLORS[][3] = {
  {255, 200, 100}, {255, 150, 50},
  {255, 180, 120}, {200, 150, 100}
};

const int DAY_COLORS[][3] = {
  {100, 200, 255}, {150, 255, 200},
  {255, 255, 200}, {200, 255, 255}
};

const int EVENING_COLORS[][3] = {
  {255, 100, 100}, {255, 150, 50},
  {200, 100, 150}, {150, 100, 200}
};

const int NIGHT_COLORS[][3] = {
  {50, 50, 150}, {100, 50, 150},
  {50, 100, 150}, {100, 100, 200}
};

const int SPECIAL_COLORS[][3] = {
  {255, 255, 255}, {255, 255, 0},
  {255, 0, 0}, {0, 255, 0}, {0, 0, 255}
};

int currentThemeColors[4][3];
int numThemeColors = 4;


// 添加亮度控制相关的常量
const int MIN_LIGHT = 0;    // 最小光照强度（lux）
const int MAX_LIGHT = 1000; // 最大光照强度（lux）
const float MIN_BRIGHTNESS = 0.2; // 最小亮度比例
const float MAX_BRIGHTNESS = 1.0; // 最大亮度比例
float currentBrightness = MAX_BRIGHTNESS;

void setColor(int r, int g, int b, float intensity) {
  intensity *= currentBrightness; // 应用全局亮度设置
  lcd.setPWM(lcd.REG_RED, r * intensity);
  lcd.setPWM(lcd.REG_GREEN, g * intensity);
  lcd.setPWM(lcd.REG_BLUE, b * intensity);
}

void adjustBrightness() {
  int lightIntensity = environment.getLuminousIntensity();
  
  // 将光照强度限制在有效范围内
  lightIntensity = constrain(lightIntensity, MIN_LIGHT, MAX_LIGHT);
  
  // 使用映射函数计算亮度
  currentBrightness = MIN_BRIGHTNESS + 
    (MAX_BRIGHTNESS - MIN_BRIGHTNESS) * 
    (float)(lightIntensity - MIN_LIGHT) / (MAX_LIGHT - MIN_LIGHT);
    
  // 使用指数曲线使亮度变化更自然
  currentBrightness = pow(currentBrightness, 0.5);
}

void updateThemeColors(int hour) {
  if (hour >= 6 && hour < 11) {
    memcpy(currentThemeColors, MORNING_COLORS, sizeof(MORNING_COLORS));
  } else if (hour >= 11 && hour < 17) {
    memcpy(currentThemeColors, DAY_COLORS, sizeof(DAY_COLORS));
  } else if (hour >= 17 && hour < 20) {
    memcpy(currentThemeColors, EVENING_COLORS, sizeof(EVENING_COLORS));
  } else {
    memcpy(currentThemeColors, NIGHT_COLORS, sizeof(NIGHT_COLORS));
  }
}

void handleSpecialEffect(unsigned long currentMillis) {
  if (!inSpecialEffect) return;
  
  const int effectDuration = 3000;
  unsigned long elapsedTime = currentMillis - specialEffectStart;
  
  if (elapsedTime > effectDuration) {
    inSpecialEffect = false;
    return;
  }

  int step = (elapsedTime / 200) % 5;
  setColor(
    SPECIAL_COLORS[step][0],
    SPECIAL_COLORS[step][1],
    SPECIAL_COLORS[step][2],
    1.0
  );
}

void displayTime() {
  lcd.clear();
  lcd.write(byte(0));
  lcd.setCursor(2, 0);
  lcd.printf("%02d:%02d:%02d", rtc.hour, rtc.minute, rtc.second);
  lcd.setCursor(0, 1);
  lcd.printf("%s %02d %s", monthNames[rtc.month-1], rtc.day, dayNames[rtc.week]);
  lcd.setCursor(15, 1);
  lcd.write(byte(1));
}

void displayEnvironmental() {
  lcd.clear();
  lcd.write(byte(1));
  lcd.printf(" %.1fC ", environment.getTemperature(TEMP_C));
  lcd.write(byte(2));
  lcd.printf(" %d%%", (int)environment.getHumidity());
  
  lcd.setCursor(0, 1);
  lcd.write(byte(3));
  lcd.printf(" %d lx", (int)environment.getLuminousIntensity());
}

void setup() {
  Serial.begin(115200);
  
  lcd.init();
  lcd.clear();
  
  lcd.customSymbol(0, clockChar);
  lcd.customSymbol(1, thermometer);
  lcd.customSymbol(2, humidityChar);
  lcd.customSymbol(3, lightChar);
  
  rtc.setup();
  //rtc.adjustRtc(2024,10,24,4,14,28,10);
  
  while(environment.begin() != 0) {
    lcd.clear();
    lcd.print("Sensor Error!");
    delay(1000);
  }
  
  randomSeed(analogRead(0));
  colorDuration = random(3000, 10000);
  
  rtc.read();
  updateThemeColors(rtc.hour);
}

void loop() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - lastUpdate >= 5000) {
    showTimeMode = !showTimeMode;
    lastUpdate = currentMillis;
  }
  
  if (currentMillis - lastEnvUpdate >= ENV_UPDATE_INTERVAL) {
    lastEnvUpdate = currentMillis;
    rtc.read();
    updateThemeColors(rtc.hour);
    
  // 在环境数据更新时调整亮度
    adjustBrightness();

    if (showTimeMode) {
      displayTime();
    } else {
      displayEnvironmental();
    }
    
    if (rtc.minute == 0 && rtc.second == 0) {
      inSpecialEffect = true;
      specialEffectStart = currentMillis;
    }
  }
  
  if (inSpecialEffect) {
    handleSpecialEffect(currentMillis);
    return;
  }
  
  if (currentMillis - lastColorChange >= colorDuration) {
    lastColorChange = currentMillis;
    currentColor = (currentColor + 1) % numThemeColors;
    colorDuration = random(3000, 10000);
    breatheValue = 1.0;
    breatheIncreasing = false;
  }
  
  float breatheSpeed = 0.0005;
  if (breatheIncreasing) {
    breatheValue += breatheSpeed;
    if (breatheValue >= 1.0) {
      breatheValue = 1.0;
      breatheIncreasing = false;
    }
  } else {
    breatheValue -= breatheSpeed;
    if (breatheValue <= 0.3) {
      breatheValue = 0.3;
      breatheIncreasing = true;
    }
  }
  
  setColor(
    currentThemeColors[currentColor][0],
    currentThemeColors[currentColor][1],
    currentThemeColors[currentColor][2],
    breatheValue
  );
}
