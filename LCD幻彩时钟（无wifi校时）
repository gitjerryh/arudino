#include <Wire.h>
#include "GravityRtc.h"
#include "DFRobot_RGBLCD1602.h"

GravityRtc rtc;
DFRobot_RGBLCD1602 lcd(0x2D, 16, 2);  // RGB controller address is 0x2D, 16 columns, 2 rows

const char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
const char* dayNames[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

unsigned long lastUpdate = 0;
int colorIndex = 0;
const int numColors = 6;
const int colors[numColors][3] = {
  {255, 0, 0},    // Red
  {255, 255, 0},  // Yellow
  {0, 255, 0},    // Green
  {0, 255, 255},  // Cyan
  {0, 0, 255},    // Blue
  {255, 0, 255}   // Magenta
};

void setColor(int r, int g, int b) {
  lcd.setPWM(lcd.REG_RED, r);
  lcd.setPWM(lcd.REG_GREEN, g);
  lcd.setPWM(lcd.REG_BLUE, b);
}

void setup() {
  Serial.begin(115200);  // Start serial communication for debugging
  
  lcd.init();
  lcd.clear();
  
  rtc.setup();
  // Set initial time when needed (uncomment and modify as needed):
//rtc.adjustRtc(F(__DATE__), F(__TIME__)); // Set from compile time
 // rtc.adjustRtc(2024,10,23,13,50,0,4);  // Set manually: Year,Month,Day,Hour,Minute,Second,Weekday
  
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("RTC initialized");
  Serial.println("RTC initialized");
  delay(2000);
}

void loop() {
  unsigned long currentMillis = millis();
  
  // Update time every second
  if (currentMillis - lastUpdate >= 1000) {
    lastUpdate = currentMillis;
    
    rtc.read();  // Read current time from RTC

    // Display time on LCD
    lcd.setCursor(0, 0);
    lcd.printf("%s %02d %s", 
              monthNames[rtc.month-1],  // Month names array is 0-based
              rtc.day, 
              dayNames[rtc.week]);  // week is already 0-based (0=Sunday)
    
    lcd.setCursor(0, 1);
    lcd.printf("%02d:%02d:%02d", 
              rtc.hour, 
              rtc.minute, 
              rtc.second);

    // Print debug info to Serial
    Serial.printf("Current time: %s %02d %s %02d:%02d:%02d\n", 
                  monthNames[rtc.month-1], 
                  rtc.day, 
                  dayNames[rtc.week],
                  rtc.hour, 
                  rtc.minute, 
                  rtc.second);

    // Gradually change color
    colorIndex = (colorIndex + 1) % numColors;
    int nextColorIndex = (colorIndex + 1) % numColors;
    float t = (currentMillis % 1000) / 1000.0;
    
    // Interpolate between current color and next color
    int r = colors[colorIndex][0] * (1-t) + colors[nextColorIndex][0] * t;
    int g = colors[colorIndex][1] * (1-t) + colors[nextColorIndex][1] * t;
    int b = colors[colorIndex][2] * (1-t) + colors[nextColorIndex][2] * t;
    
    setColor(r, g, b);
  }
}
