#include <Wire.h>
#include "GravityRtc.h"
#include "DFRobot_RGBLCD1602.h"
#include "DFRobot_EnvironmentalSensor.h"
#include <WiFi.h>
#include <WebServer.h>
#include <DNSServer.h>
#include <time.h>
#include <ArduinoJson.h>

// AP模式的配置
const char* AP_SSID = "ESP32_RTC_Config";  // AP模式的SSID
const char* AP_PASSWORD = "12345678";       // AP模式的密码
IPAddress apIP(192, 168, 4, 1);            // AP模式的IP地址
DNSServer dnsServer;
WebServer server(80);

// 添加时间更新相关的全局变量
unsigned long lastTimeUpdate = 0;
char cachedTimeStr[20] = "00:00:00";  // 初始化为默认值

// 添加新的全局变量（移到文件前面）
bool isManualColorControl = false;  // 是否处于手动控制模式
unsigned long lastColorControlTime = 0;  // 最后一次手动控制的时间
const unsigned long COLOR_CONTROL_TIMEOUT = 5000;  // 手动控制超时时间（5秒）

// 添加全局变量用于保存手动设置的颜色
int manualColors[3];

// 在全局变量区域定义手动模式的亮度
const float MANUAL_MODE_BRIGHTNESS = 1.0;  // 手动模式下使用的亮度

// 添加新的全局变量用于Web界面更新
unsigned long lastWebUpdate = 0;
const unsigned long WEB_UPDATE_INTERVAL = 50;  // 降低到50ms以提高更新频率
const unsigned long COLOR_UPDATE_INTERVAL = 50; // 添加颜色更新间隔

// 添加新的全局变量
unsigned long lastColorUpdate = 0;
bool colorNeedsUpdate = false;
int pendingColors[3] = {0, 0, 0};

// 修改全局变量区域的呼吸效果相关常量
const float BREATHE_MIN = 0.2;  // 最小亮度
const float BREATHE_MAX = 1.0;   // 最大亮度
const float BREATHE_SPEED_NORMAL = 0.001;  // 降低正常呼吸速度
const float BREATHE_SPEED_SLOW = 0.0005;   // 降低慢速呼吸速度
float currentBreatheSpeed = BREATHE_SPEED_NORMAL;

// 添加新的呼吸效果相关变量
float breathePhase = 0.0;        // 呼吸相位
float breatheVariation = 1.0;    // 呼吸变化率
const float VARIATION_MIN = 0.8; // 最小变化率
const float VARIATION_MAX = 1.2; // 最大变化率
unsigned long lastVariationChange = 0;
const unsigned long VARIATION_INTERVAL = 3000; // 变化间隔

// 函数声明
void handleRoot();
void handleTimeSync();
void handleNotFound();
void handleScanWiFi();
void handleConnectWiFi();
void restoreOriginalChars();
void displayTime();
void displayEnvironmental();
void handleSpecialEffect(unsigned long currentMillis);
void handleAdvancedHourlyEffect();
void handleHourlyEffect(unsigned long currentMillis);
void handleWeatherEffect(unsigned long currentMillis);
void handleTransition(unsigned long currentMillis);

// NTP服务器配置
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 8 * 3600;  // 以中国时区为例，UTC+8
const int   daylightOffset_sec = 0;

// 时间同步状态
bool timeNeedSync = false;
unsigned long lastSyncAttempt = 0;
const unsigned long SYNC_INTERVAL = 24 * 60 * 60 * 1000; // 24小时同步一次

GravityRtc rtc;
DFRobot_RGBLCD1602 lcd(0x2D, 16, 2);
DFRobot_EnvironmentalSensor environment(SEN050X_DEFAULT_DEVICE_ADDRESS, &Wire);

const char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
const char* dayNames[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

unsigned long lastUpdate = 0;
unsigned long lastColorChange = 0;
unsigned long lastEnvUpdate = 0;
unsigned long colorDuration = 0;
unsigned long specialEffectStart = 0;
const unsigned long ENV_UPDATE_INTERVAL = 1000;
bool showTimeMode = true;

const unsigned long ENV_DISPLAY_DURATION = 15000;  // 环境显示持续3秒
const float ENV_DISPLAY_PROBABILITY = 0.1;        // 修改为30%的概率切换到环境显示
unsigned long envDisplayStartTime = 0;            // 环境显示开始时间
bool forceTimeDisplay = true;                     // 强制时间显示标志

int currentColor = 0;
float breatheValue = 0;
bool breatheIncreasing = true;
bool inSpecialEffect = false;
int specialEffectStep = 0;
float lastTemp = 0.0;  // 在全局变量区域添加这个变量
unsigned long lastHueUpdate = 0;
// Custom characters
byte clockChar[8] = {
  B00000, B01110, B10101, B10111,
  B10001, B01110, B00000, B00000
};

byte thermometer[8] = {
  B00100, B01010, B01010, B01110,
  B01110, B11111, B11111, B01110
};

byte humidityChar[8] = {
  B00100, B00100, B01110, B01110,
  B11111, B11111, B01110, B00000
};

byte lightChar[8] = {
  B00000, B10101, B01110, B11111,
  B01110, B10101, B00000, B00000
};

// Color themes
const int MORNING_COLORS[][3] = {
    {255, 200, 100},  // 原有的暖黄色
    {255, 150, 50},   // 原有的橙色
    {255, 180, 120},  // 原有的浅橙色
    {200, 150, 100},  // 原有的暖棕色
    {255, 140, 0},    // 新增：深橙色
    {255, 215, 150},  // 新增：杏仁色
    {255, 127, 80},   // 新增：珊瑚色
    {255, 190, 150}   // 新增：蜜桃色
};

const int DAY_COLORS[][3] = {
    {100, 200, 255},  // 原有的天蓝色
    {150, 255, 200},  // 原有的青绿色
    {255, 255, 200},  // 原有的暖白色
    {200, 255, 255},  // 原有的浅青色
    {0, 191, 255},    // 新增：深天蓝
    {127, 255, 170},  // 新增：碧绿色
    {64, 224, 208},   // 新增：绿松石色
    {135, 206, 250}   // 新增：淡天蓝
};

const int EVENING_COLORS[][3] = {
    {255, 100, 100},  // 原有的粉红色
    {255, 150, 50},   // 原有的橙色
    {200, 100, 150},  // 原有的紫粉色
    {150, 100, 200},  // 原有的淡紫色
    {255, 69, 0},     // 新增：红橙色
    {255, 20, 147},   // 新增：深粉色
    {219, 112, 147},  // 新增：浅紫红
    {186, 85, 211}    // 新增：中紫色
};

const int NIGHT_COLORS[][3] = {
    {50, 50, 150},    // 原有的深蓝色
    {100, 50, 150},   // 原有的蓝紫色
    {50, 100, 150},   // 原有的靛蓝色
    {100, 100, 200},  // 原有的淡蓝紫色
    {25, 25, 112},    // 新增：午夜蓝
    {72, 61, 139},    // 新增：暗紫色
    {0, 0, 128},      // 新增：海军蓝
    {138, 43, 226}    // 新增：紫罗兰色
};

const int SPECIAL_COLORS[][3] = {
  {255, 255, 255}, {255, 255, 0},
  {255, 0, 0}, {0, 255, 0}, {0, 0, 255}
};



int currentThemeColors[8][3];
int numThemeColors = 8;

// 为每个星期设计不同的动画图案
byte animationFrames[7][4][8] = {
  // 星期日 - 太阳动画
  {
    {B00000,B00100,B10101,B01110,B11111,B01110,B10101,B00100},
    {B00100,B10101,B01110,B11111,B01110,B10101,B00100,B00000},
    {B10101,B01110,B11111,B01110,B10101,B00100,B00000,B00100},
    {B01110,B11111,B01110,B10101,B00100,B00000,B00100,B10101}
  },
  // 星期一 - 流星雨动画
  {
    {B10000,B01000,B00100,B00010,B00000,B00000,B00000,B00000},
    {B00000,B10000,B01000,B00100,B00010,B00000,B00000,B00000},
    {B00000,B00000,B10000,B01000,B00100,B00010,B00000,B00000},
    {B00000,B00000,B00000,B10000,B01000,B00100,B00010,B00000}
  },
  // 星期二 - 风车动画
  {
  {B00100, B00100, B11111, B00100, B00100, B00000, B00000, B00000},
  {B00000, B00100, B00100, B11111, B00100, B00100, B00000, B00000},
  {B00000, B00000, B00100, B00100, B11111, B00100, B00100, B00000},
  {B00000, B00000, B00000, B00100, B00100, B11111, B00100, B00100}
  },
  // 星期三 - 星星动画
  {
    {B00000,B00100,B01110,B11111,B01110,B10101,B01010,B00000},
    {B00100,B01110,B11111,B01110,B10101,B01010,B00000,B00000},
    {B01110,B11111,B01110,B10101,B01010,B00000,B00100,B00000},
    {B11111,B01110,B10101,B01010,B00000,B00100,B01110,B00000}
  },
  // 星期四 - 心跳动画
  {
    {B00000,B01010,B11111,B11111,B01110,B00100,B00000,B00000},
    {B01010,B11111,B11111,B01110,B00100,B00000,B00000,B00000},
    {B11111,B11111,B01110,B00100,B00000,B00000,B01010,B00000},
    {B11111,B01110,B00100,B00000,B00000,B01010,B11111,B00000}
  },
  // 星期五 - 音符动画
  {
    {B00100,B00110,B00101,B00100,B01100,B11100,B11100,B00000},
    {B00110,B00101,B00100,B01100,B11100,B11100,B00000,B00100},
    {B00101,B00100,B01100,B11100,B11100,B00000,B00100,B00110},
    {B00100,B01100,B11100,B11100,B00000,B00100,B00110,B00101}
  },
  // 星期六 - 花朵动画
  {
    {B00100,B01110,B00100,B00000,B00000,B00000,B00000,B00000},
    {B00000,B01110,B01110,B01110,B00000,B00000,B00000,B00000},
    {B00000,B10101,B01110,B10101,B01110,B00100,B00000,B00000},
    {B10101,B01110,B11111,B01110,B10101,B01010,B00100,B00000}
  }
};


int currentFrame = 0;
unsigned long lastFrameUpdate = 0;
const unsigned long FRAME_INTERVAL = 100; // 动画帧更新间隔
// 添加在全局变量区域
int scrollPosition = 0;
unsigned long lastScrollTime = 0;
const unsigned long SCROLL_INTERVAL = 400; // 滚动间隔时间(ms)
String envDataString = ""; // 用于存储环境数据的完整字符串

// 添加亮度控制相关的常量
const int MIN_LIGHT = 0;    // 最小光照强度（lux）
const int MAX_LIGHT = 1000; // 最大光照强度（lux）
const float MIN_BRIGHTNESS = 0.2; // 最小亮度比例
const float MAX_BRIGHTNESS = 1.0; // 最大亮度比例
float currentBrightness = MAX_BRIGHTNESS;

// 新增整点特效相关变量
struct HourlyEffect {
    byte patterns[8][8];  // 整点动画帧
    int colors[8][3];     // 整点颜色序列
    int duration;         // 效果持续时间(ms)
    byte type;           // 效果类型(0:扫描, 1:闪烁, 2:波浪, 3:螺旋)
};

// Improved morning effect (Sunrise spiral)
const HourlyEffect MORNING_EFFECT = {
    {
        {B00000,B00000,B00000,B00100,B00000,B00000,B00000,B00000},
        {B00000,B00000,B01110,B01110,B01110,B00000,B00000,B00000},
        {B00000,B01110,B11111,B11111,B11111,B01110,B00000,B00000},
        {B00100,B01110,B11111,B11111,B11111,B01110,B00100,B00000},
        {B01110,B11111,B11111,B11111,B11111,B11111,B01110,B00000},
        {B11111,B11111,B11111,B11111,B11111,B11111,B11111,B00000},
        {B11111,B11111,B11111,B11111,B11111,B11111,B11111,B11111},
        {B01110,B11111,B11111,B11111,B11111,B11111,B01110,B00000}
    },
    {
        {255,100,0}, {255,120,20}, {255,140,40}, {255,160,60},
        {255,180,80}, {255,200,100}, {255,220,120}, {255,240,140}
    },
    5000,
    0
};

// New day effect (Pulsing sun rays)
const HourlyEffect DAY_EFFECT = {
    {
        {B10101,B01110,B11111,B01110,B10101,B00000,B00000,B00000},
        {B00000,B10101,B01110,B11111,B01110,B10101,B00000,B00000},
        {B00000,B00000,B10101,B01110,B11111,B01110,B10101,B00000},
        {B00000,B00000,B00000,B10101,B01110,B11111,B01110,B10101},
        {B10101,B00000,B00000,B00000,B10101,B01110,B11111,B01110},
        {B01110,B10101,B00000,B00000,B00000,B10101,B01110,B11111},
        {B11111,B01110,B10101,B00000,B00000,B00000,B10101,B01110},
        {B01110,B11111,B01110,B10101,B00000,B00000,B00000,B10101}
    },
    {
        {100,200,255}, {150,220,255}, {200,240,255}, {255,255,200},
        {255,240,150}, {255,220,100}, {200,240,255}, {150,220,255}
    },
    6000,
    1
};

// Improved evening effect (Sunset waves)
const HourlyEffect EVENING_EFFECT = {
    {
        {B11111,B11111,B00000,B00000,B00000,B00000,B00000,B00000},
        {B01111,B11111,B11111,B00000,B00000,B00000,B00000,B00000},
        {B00111,B01111,B11111,B11111,B00000,B00000,B00000,B00000},
        {B00011,B00111,B01111,B11111,B11111,B00000,B00000,B00000},
        {B00001,B00011,B00111,B01111,B11111,B11111,B00000,B00000},
        {B00000,B00001,B00011,B00111,B01111,B11111,B11111,B00000},
        {B00000,B00000,B00001,B00011,B00111,B01111,B11111,B11111},
        {B00000,B00000,B00000,B00001,B00011,B00111,B01111,B11111}
    },
    {
        {255,50,0}, {255,30,0}, {200,20,0}, {150,10,0},
        {100,5,0}, {50,0,0}, {25,0,0}, {10,0,0}
    },
    4000,
    2
};

// Enhanced night effect (Twinkling stars)
const HourlyEffect NIGHT_EFFECT = {
    {
        {B10001,B00000,B00100,B00000,B10001,B00000,B00100,B00000},
        {B00000,B01010,B00000,B00100,B00000,B01010,B00000,B00100},
        {B00100,B00000,B10001,B00000,B00100,B00000,B10001,B00000},
        {B00000,B00100,B00000,B01010,B00000,B00100,B00000,B01010},
        {B01010,B00000,B00100,B00000,B01010,B00000,B00100,B00000},
        {B00000,B10001,B00000,B00100,B00000,B10001,B00000,B00100},
        {B00100,B00000,B01010,B00000,B00100,B00000,B01010,B00000},
        {B00000,B00100,B00000,B10001,B00000,B00100,B00000,B10001}
    },
    {
        {50,50,150}, {40,40,130}, {30,30,110}, {20,20,90},
        {10,10,70}, {5,5,50}, {20,20,90}, {40,40,130}
    },
    7000,
    3
};
bool isHourlyEffect = false;
unsigned long hourlyEffectStart = 0;
int hourlyEffectFrame = 0;
const HourlyEffect* currentHourlyEffect = nullptr;

// 添加全局变量用于保存原始字符
byte originalChars[4][8];  // 保存0-3号位置的原始字符

bool syncTimeFromNTP() {
  struct tm timeinfo;
  bool success = false;
  
  // 保存当前WiFi模式
  WiFiMode_t currentMode = WiFi.getMode();
  
  // 切换到STA模式并尝试连接WiFi
  WiFi.mode(WIFI_STA);
  
  // 扫描可用网络
  int n = WiFi.scanNetworks();
  if (n > 0) {
    // 这里可以添加已知的WiFi凭据
    const char* known_ssids[] = {"Your_SSID_1", "Your_SSID_2"};
    const char* known_passwords[] = {"Your_Password_1", "Your_Password_2"};
    const int known_networks = sizeof(known_ssids) / sizeof(known_ssids[0]);
    
    for (int i = 0; i < n; i++) {
      String ssid = WiFi.SSID(i);
      for (int j = 0; j < known_networks; j++) {
        if (ssid.equals(known_ssids[j])) {
          // 尝试连接已知网络
          WiFi.begin(known_ssids[j], known_passwords[j]);
          
          // 等待连接，最多等待10秒
          int attempts = 0;
          while (WiFi.status() != WL_CONNECTED && attempts < 20) {
            delay(500);
            attempts++;
          }
          
          if (WiFi.status() == WL_CONNECTED) {
            // 配置NTP
            configTime(gmtOffset_sec, daylightOffset_sec, ntpServer, "time.nist.gov", "time.windows.com");
            
            // 等待NTP同步，最多等待5秒
            int timeoutCount = 0;
            while (!getLocalTime(&timeinfo) && timeoutCount < 10) {
              delay(500);
              timeoutCount++;
            }
            
            if (getLocalTime(&timeinfo)) {
              // 更新RTC时间
              rtc.adjustRtc(timeinfo.tm_year + 1900, 
                          timeinfo.tm_mon + 1,
                          timeinfo.tm_mday,
                          timeinfo.tm_wday,
                          timeinfo.tm_hour,
                          timeinfo.tm_min,
                          timeinfo.tm_sec);
              success = true;
              break;
            }
          }
        }
      }
      if (success) break;
    }
  }
  
  // 断开WiFi连接
  WiFi.disconnect(true);
  
  // 恢复之前的WiFi模式
  WiFi.mode(currentMode);
  
  return success;
}

void setColor(int r, int g, int b, float intensity) {
    // 应用全局亮度设置，但确保手动模式下颜色足够明显
    float finalIntensity = intensity * (isManualColorControl ? MANUAL_MODE_BRIGHTNESS : currentBrightness);
    
    // 使用浮点数计算以提高精度
    float fr = r * finalIntensity;
    float fg = g * finalIntensity;
    float fb = b * finalIntensity;
    
    // 确保值在有效范围内
    lcd.setPWM(lcd.REG_RED, constrain((int)fr, 0, 255));
    lcd.setPWM(lcd.REG_GREEN, constrain((int)fg, 0, 255));
    lcd.setPWM(lcd.REG_BLUE, constrain((int)fb, 0, 255));
}



// 处���根路径请求
void handleRoot() {
    String html = "<!DOCTYPE html><html><head>";
    html += "<meta charset='UTF-8'>";  // 添加UTF-8编码支持
    html += "<meta name='viewport' content='width=device-width, initial-scale=1'>";
    // 添�������Google Fonts支持
    html += "<link href='https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap' rel='stylesheet'>";
    
    html += "<style>";
    // 基础样式
    html += "* { margin: 0; padding: 0; box-sizing: border-box; }";
    html += "body { font-family: 'Noto Sans SC', sans-serif; background: linear-gradient(45deg, #1a2a6c, #b21f1f, #fdbb2d); min-height: 100vh; }";
    
    // 容器样式
    html += ".container { max-width: 90%; width: 400px; margin: 30px auto; background: rgba(255, 255, 255, 0.95); ";
    html += "padding: 25px; border-radius: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); backdrop-filter: blur(10px); }";
    
    // 标题样式
    html += "h1 { color: #333; text-align: center; font-size: 24px; margin-bottom: 20px; }";
    html += "h2 { color: #444; text-align: center; font-size: 18px; margin: 20px 0; }";
    
    // 时间显示样式
    html += ".time-display { text-align: center; font-size: 20px; color: #333; margin: 15px 0; padding: 10px; }";
    html += "#current-time { font-weight: bold; color: #1a2a6c; }";
    
    // 按钮样式
    html += ".btn { background: linear-gradient(45deg, #1a2a6c, #2a3a7c); color: white; border: none; ";
    html += "padding: 12px 25px; border-radius: 25px; cursor: pointer; font-size: 16px; width: 100%; ";
    html += "margin: 10px 0; transition: all 0.3s ease; font-weight: 500; }";
    html += ".btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.2); }";
    
    // WiFi列表样式
    html += ".wifi-list { margin: 20px 0; }";
    html += ".wifi-item { background: white; padding: 15px; margin: 8px 0; border-radius: 12px; ";
    html += "cursor: pointer; transition: all 0.3s ease; display: flex; justify-content: space-between; ";
    html += "align-items: center; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }";
    html += ".wifi-item:hover { transform: translateX(5px); background: #f8f9fa; }";
    
    // 信号强度指示器
    html += ".signal-strength { font-size: 14px; color: #666; }";
    
    // 状态消息样式
    html += ".status { margin: 15px 0; padding: 12px; border-radius: 8px; text-align: center; transition: all 0.3s ease; }";
    html += ".success { background: #d4edda; color: #155724; border-left: 4px solid #155724; }";
    html += ".error { background: #f8d7da; color: #721c24; border-left: 4px solid #721c24; }";
    
    // 表单样式
    html += ".form-control { width: 100%; padding: 12px; margin: 8px 0; border: 1px solid #ddd; ";
    html += "border-radius: 8px; font-size: 16px; transition: all 0.3s ease; }";
    html += ".form-control:focus { outline: none; border-color: #1a2a6c; box-shadow: 0 0 0 2px rgba(26,42,108,0.2); }";
    
    // 确保 wifi-form 在显示时位于正确的位置
    html += "#wifi-form { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); ";
    html += "background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); ";
    html += "z-index: 1000; width: 90%; max-width: 400px; }";
    
    // 添加遮罩层样式
    html += ".overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; ";
    html += "background: rgba(0,0,0,0.5); z-index: 999; }";
    
    html += ".color-picker-container { margin: 20px 0; padding: 15px; background: #fff; border-radius: 12px; }";
    html += ".color-picker { width: 100%; height: 150px; position: relative; margin-bottom: 15px; ";
    html += "background: linear-gradient(to bottom, #fff 0%, #000 100%), ";
    html += "linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%); ";
    html += "background-blend-mode: multiply; cursor: crosshair; }";
    html += ".current-color { width: 100%; height: 40px; border-radius: 8px; margin-top: 10px; border: 2px solid #ddd; }";
    
    html += "</style></head>";
    
    // Body内容
    html += "<body>";
    html += "<div class='overlay' id='overlay'></div>";  // 添加遮罩层
    html += "<div class='container'>";
    html += "<h1>ESP32 智能时钟配置</h1>";
    html += "<div class='time-display'>当前时间: <span id='current-time'>--:--:--</span></div>";
    html += "<button class='btn' onclick='syncTime()'>同步时间</button>";
    html += "<div id='status' class='status'></div>";
    
    html += "<h2>可用WiFi网络</h2>";
    html += "<button class='btn' onclick='scanWiFi()'>扫描WiFi</button>";
    html += "<div id='wifi-list' class='wifi-list'></div>";
    
    // WiFi连接表单
    html += "<div id='wifi-form' style='display:none;'>";
    html += "<div class='form-container' style='background:#f8f9fa; padding:20px; border-radius:12px; margin-top:20px; border:1px solid #dee2e6;'>";
    html += "<h2 style='margin-bottom:15px;'>连接到 <span id='selected-wifi-name'></span></h2>";
    html += "<form id='connect-form'>";
    html += "<input type='hidden' id='selected-ssid' name='ssid'>";
    html += "<div class='input-group' style='margin-bottom:15px;'>";
    html += "<input type='password' name='password' class='form-control' placeholder='请输入WiFi密码' required>";
    html += "</div>";
    html += "<div class='button-group'>";
    html += "<button type='button' class='btn' style='background:linear-gradient(45deg,#6c757d,#495057);margin-bottom:10px;' onclick='cancelConnect()'>取消</button>";
    html += "<button type='submit' class='btn'>连接</button>";
    html += "</div>";
    html += "</form></div></div>";
    
    // 添加颜色选择器容器
    html += "<div class='color-picker-container'>";
    html += "<h2>背光颜色控制</h2>";
    html += "<div class='color-picker' id='colorPicker'></div>";
    html += "<div class='current-color' id='currentColor'></div>";
    html += "</div>";
    
    // JavaScript代码
    html += "<script>";
    // 更新时间函数
    html += "function updateTime() {";
    html += "fetch('/time').then(r=>r.text()).then(t=>{";
    html += "document.getElementById('current-time').innerHTML=t;";
    html += "}).catch(()=>{});";
    html += "}";
    html += "setInterval(updateTime,1000);";
    
    // 同步时间函数
    html += "function syncTime() {";
    html += "const status=document.getElementById('status');";
    html += "status.innerHTML='正在同步...';";
    html += "status.className='status';";
    html += "fetch('/sync').then(r=>r.text()).then(data=>{";
    html += "status.innerHTML=data.includes('success')?'同步成功！':'同步失败';";
    html += "status.className='status '+(data.includes('success')?'success':'error');";
    html += "});";
    html += "}";
    
    // 扫描WiFi函数
    html += "function scanWiFi() {";
    html += "const list=document.getElementById('wifi-list');";
    html += "list.innerHTML='<div style=\"text-align:center;color:#666;\">正在扫描...</div>';";
    html += "fetch('/scan-wifi').then(r=>r.json()).then(networks=>{";
    html += "let html='';";
    html += "networks.sort((a,b)=>b.rssi-a.rssi).forEach(net=>{";
    html += "const strength=net.rssi>-50?'强':net.rssi>-70?'中':'弱';";
    html += "html+='<div class=\"wifi-item\" onclick=\"selectWiFi(\\''+net.ssid+'\\')\">';";
    html += "html+='<span>'+net.ssid+'</span><span class=\"signal-strength\">信号:'+strength+'</span></div>';";
    html += "});";
    html += "list.innerHTML=html||'<div style=\"text-align:center;color:#666;\">未找到WiFi网络</div>';";
    html += "}).catch(error => {";
    html += "list.innerHTML='<div style=\"text-align:center;color:#721c24;\">扫描失败，请重试</div>';";
    html += "console.error('Error:', error);";
    html += "});";
    html += "}";
    
    // 选择WiFi函数
    html += "function selectWiFi(ssid){";
    html += "document.getElementById('selected-ssid').value=ssid;";
    html += "document.getElementById('selected-wifi-name').textContent=ssid;";
    html += "document.getElementById('wifi-form').style.display='block';";
    html += "document.getElementById('overlay').style.display='block';";
    html += "document.querySelector('input[name=\"password\"]').focus();";
    html += "}";
    
    // 添加取消连接的函数
    html += "function cancelConnect(){";
    html += "document.getElementById('wifi-form').style.display='none';";
    html += "document.getElementById('overlay').style.display='none';";
    html += "document.getElementById('connect-form').reset();";
    html += "}";
    
    // 添加点击遮罩层关闭表单的功能
    html += "document.getElementById('overlay').onclick=function(){";
    html += "cancelConnect();";
    html += "};";
    
    // 表单提交处理
    html += "document.getElementById('connect-form').onsubmit=function(e){";
    html += "e.preventDefault();";
    html += "const status=document.getElementById('status');";
    html += "const formData=new FormData(e.target);";
    html += "status.innerHTML='正在连接...';";
    html += "status.className='status';";
    html += "fetch('/connect-wifi',{";
    html += "method:'POST',";
    html += "body:formData";
    html += "}).then(r=>r.text()).then(data=>{";
    html += "status.innerHTML=data.includes('success')?'连接成功！':'连接失败';";
    html += "status.className='status '+(data.includes('success')?'success':'error');";
    html += "if(data.includes('success')){";
    html += "setTimeout(()=>{document.getElementById('wifi-form').style.display='none';";
    html += "document.getElementById('overlay').style.display='none';},2000);";
    html += "}";
    html += "}).catch(error=>{";
    html += "status.innerHTML='连接失败';";
    html += "status.className='status error';";
    html += "console.error('Error:', error);";
    html += "});";
    html += "};";
    
    html += "const colorPicker = document.getElementById('colorPicker');";
    html += "const currentColor = document.getElementById('currentColor');";
    html += "let isPickingColor = false;";

    html += "function rgbToHex(r, g, b) {";
    html += "  return '#' + [r, g, b].map(x => {";
    html += "    const hex = Math.round(x).toString(16);";
    html += "    return hex.length === 1 ? '0' + hex : hex;";
    html += "  }).join('');";
    html += "}";

    html += "function updateColor(e) {";
    html += "  const rect = colorPicker.getBoundingClientRect();";
    html += "  let clientX, clientY;";
    html += "  if (e.touches) {";
    html += "    clientX = e.touches[0].clientX;";
    html += "    clientY = e.touches[0].clientY;";
    html += "  } else {";
    html += "    clientX = e.clientX;";
    html += "    clientY = e.clientY;";
    html += "  }";
    html += "  const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));";
    html += "  const y = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));";
    html += "  const hue = x * 360;";
    html += "  const saturation = 1;";
    html += "  const lightness = 1 - y;";
    html += "  const color = hslToRgb(hue/360, saturation, lightness);";
    html += "  const hexColor = rgbToHex(color[0], color[1], color[2]);";
    html += "  currentColor.style.backgroundColor = hexColor;";
    
    // 添加节流逻辑，限制请求频率
    html += "  if(!window.colorUpdateTimeout) {";
    html += "    window.colorUpdateTimeout = setTimeout(() => {";
    html += "      fetch('/set-color', {";
    html += "        method: 'POST',";
    html += "        headers: {'Content-Type': 'application/json'},";
    html += "        body: JSON.stringify({r: color[0], g: color[1], b: color[2]})";
    html += "      });";
    html += "      window.colorUpdateTimeout = null;";
    html += "    }, 50);"; // 50ms 的节流时间
    html += "  }";
    html += "}";

    html += "let touchMoved = false;";
    html += "colorPicker.addEventListener('touchstart', (e) => {";
    html += "  touchMoved = false;";
    html += "  isPickingColor = true;";
    html += "  updateColor(e);";
    html += "  e.preventDefault();";
    html += "}, { passive: false });";

    html += "colorPicker.addEventListener('touchmove', (e) => {";
    html += "  touchMoved = true;";
    html += "  updateColor(e);";
    html += "  e.preventDefault();";
    html += "}, { passive: false });";

    html += "colorPicker.addEventListener('touchend', (e) => {";
    html += "  isPickingColor = false;";
    html += "  if (!touchMoved) {";
    html += "    const touch = e.changedTouches[0];";
    html += "    updateColor(touch);";
    html += "  }";
    html += "  e.preventDefault();";
    html += "}, { passive: false });";

    html += "function hslToRgb(h, s, l) {";
    html += "  let r, g, b;";
    html += "  if (s === 0) {";
    html += "    r = g = b = l;";
    html += "  } else {";
    html += "    const hue2rgb = (p, q, t) => {";
    html += "      if (t < 0) t += 1;";
    html += "      if (t > 1) t -= 1;";
    html += "      if (t < 1/6) return p + (q - p) * 6 * t;";
    html += "      if (t < 1/2) return q;";
    html += "      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;";
    html += "      return p;";
    html += "    };";
    html += "    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;";
    html += "    const p = 2 * l - q;";
    html += "    r = hue2rgb(p, q, h + 1/3);";
    html += "    g = hue2rgb(p, q, h);";
    html += "    b = hue2rgb(p, q, h - 1/3);";
    html += "  }";
    html += "  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];";
    html += "}";

    // 添加鼠标事件处理
    html += "colorPicker.addEventListener('mousedown', (e) => {";
    html += "  isPickingColor = true;";
    html += "  updateColor(e);";
    html += "});";

    html += "colorPicker.addEventListener('mousemove', (e) => {";
    html += "  if (isPickingColor) {";
    html += "    updateColor(e);";
    html += "  }";
    html += "});";

    html += "document.addEventListener('mouseup', () => {";
    html += "  isPickingColor = false;";
    html += "});";

    html += "</script></div></body></html>";
    
    server.send(200, "text/html", html);
}

// 处理时间同步请求
void handleTimeSync() {
  if (syncTimeFromNTP()) {
    server.send(200, "text/plain", "Time synced successfully!");
  } else {
    server.send(500, "text/plain", "Failed to sync time!");
  }
}

// 处理404请求
void handleNotFound() {
  server.sendHeader("Location", "/", true);
  server.send(302, "text/plain", "");
}
void setupAP() {
  WiFi.mode(WIFI_AP);
  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));
  WiFi.softAP(AP_SSID, AP_PASSWORD);

  // 配置DNS服务器，将所有域名请求定向到ESP32
  dnsServer.start(53, "*", apIP);

  // 配置Web服务器路由
  server.on("/", HTTP_GET, handleRoot);
  server.on("/sync", HTTP_GET, handleTimeSync);
  server.on("/scan-wifi", HTTP_GET, handleScanWiFi);  // 新����
  server.on("/connect-wifi", HTTP_POST, handleConnectWiFi);  // 新增
  server.onNotFound(handleNotFound);
  
  server.begin();
}
void adjustBrightness() {
  int lightIntensity = environment.getLuminousIntensity();
  
  // 将光照强限制在有效范围内
  lightIntensity = constrain(lightIntensity, MIN_LIGHT, MAX_LIGHT);
  
  // 使用映射函数计算亮度
  currentBrightness = MIN_BRIGHTNESS + 
    (MAX_BRIGHTNESS - MIN_BRIGHTNESS) * 
    (float)(lightIntensity - MIN_LIGHT) / (MAX_LIGHT - MIN_LIGHT);
    
  // 使用指数线使亮度变化更自
  currentBrightness = pow(currentBrightness, 0.5);
}

void updateThemeColors(int hour) {
  if (hour >= 6 && hour < 11) {
    memcpy(currentThemeColors, MORNING_COLORS, sizeof(MORNING_COLORS));
  } else if (hour >= 11 && hour < 17) {
    memcpy(currentThemeColors, DAY_COLORS, sizeof(DAY_COLORS));
  } else if (hour >= 17 && hour < 20) {
    memcpy(currentThemeColors, EVENING_COLORS, sizeof(EVENING_COLORS));
  } else {
    memcpy(currentThemeColors, NIGHT_COLORS, sizeof(NIGHT_COLORS));
  }
}

void handleSpecialEffect(unsigned long currentMillis) {
  if (!inSpecialEffect) return;
  
  const int effectDuration = 3000;
  unsigned long elapsedTime = currentMillis - specialEffectStart;
  
  if (elapsedTime > effectDuration) {
    inSpecialEffect = false;
    return;
  }

  int step = (elapsedTime / 200) % 5;
  setColor(
    SPECIAL_COLORS[step][0],
    SPECIAL_COLORS[step][1],
    SPECIAL_COLORS[step][2],
    1.0
  );
}

void displayTime() {
    // 确保正确的字符设置
    if (!isHourlyEffect) {
        restoreOriginalChars();
    }
    
    unsigned long currentMillis = millis();
    
    if (currentMillis - lastFrameUpdate >= FRAME_INTERVAL) {
        lastFrameUpdate = currentMillis;
        currentFrame = (currentFrame + 1) % 4;
        
        // 更新动画字符（使用4-7号位置）
        for(int i = 0; i < 4; i++) {
            lcd.customSymbol(4 + i, animationFrames[rtc.week][(currentFrame + i) % 4]);
        }
    }
    
    // 先清屏
    lcd.clear();
    
    // 第一行：时钟图标和时间
    lcd.setCursor(0, 0);
    lcd.write(byte(0));  // 时钟图标
    lcd.setCursor(2, 0);
    lcd.printf("%02d:%02d:%02d", rtc.hour, rtc.minute, rtc.second);
    
    // 第一行右侧动画
    lcd.setCursor(12, 0);
    lcd.write(byte(4));
    lcd.write(byte(5));
    
    // 第二行：日期和星期
    lcd.setCursor(0, 1);
    // 确保日期和星期的显示
    if(rtc.month >= 1 && rtc.month <= 12 && rtc.week >= 0 && rtc.week <= 6) {
        lcd.printf("%s %02d %s", monthNames[rtc.month-1], rtc.day, dayNames[rtc.week]);
    } else {
        lcd.print("Date Error!"); // 错误提示
    }
    
    // 第二行右侧动画
    lcd.setCursor(12, 1);
    lcd.write(byte(6));
    lcd.write(byte(7));
}

void displayEnvironmental() {
    // 确保正确的字符设置
    if (!isHourlyEffect) {
        restoreOriginalChars();
    }
    
    // 更新环境数据字符串
    char tempStr[80];
    float temp = environment.getTemperature(TEMP_C);
    int humidity = (int)environment.getHumidity();
    int light = (int)environment.getLuminousIntensity();
    
    // 检查数据有效性
    if (isnan(temp) || humidity < 0 || humidity > 100 || light < 0) {
        sprintf(tempStr, "Sensor Error!");
    } else {
        sprintf(tempStr, "  \1%.1fC  \2%d%%  \3%d lx  ", temp, humidity, light);
    }
    envDataString = String(tempStr);
    
    unsigned long currentMillis = millis();
    if (currentMillis - lastScrollTime >= SCROLL_INTERVAL) {
        lastScrollTime = currentMillis;
        scrollPosition++;
        if (scrollPosition >= envDataString.length()) {
            scrollPosition = 0;
        }
        
        // 清屏以防止残留
        lcd.clear();
        
        // 准备显示字符串
        String displayStr = envDataString.substring(scrollPosition);
        displayStr += envDataString.substring(0, scrollPosition);
        
        // 确保在两行都显示
        for (int row = 0; row < 2; row++) {
            lcd.setCursor(0, row);
            String lineStr = displayStr.substring(0, min(16, (int)displayStr.length()));
            
            // 逐字符显示，确保特殊字符正确显示
            for (int i = 0; i < lineStr.length(); i++) {
                char c = lineStr.charAt(i);
                if (c == '\1') {
                    lcd.write(byte(1));  // 温度计图标
                } else if (c == '\2') {
                    lcd.write(byte(2));  // 湿度图标
                } else if (c == '\3') {
                    lcd.write(byte(3));  // 光照图标
                } else {
                    lcd.write(c);
                }
            }
        }
    }
}
const struct {
  int month;
  int day;
  const char* name;
  const int colors[5][3];
} HOLIDAYS[] = {
  {1, 1, "New Year", {{255,0,0}, {255,215,0}, {255,255,255}, {255,192,203}, {255,69,0}}},
  {12, 25, "Christmas", {{255,0,0}, {0,255,0}, {255,255,255}, {255,215,0}, {0,128,0}}},
  // 可以添加更多节日
};

// 新增天气效果相关变量
float tempHue = 0.0;
float tempOffset = 0.0;
bool isWeatherEffect = false;
unsigned long weatherEffectStart = 0;
const unsigned long WEATHER_EFFECT_DURATION = 5000;

// 新增转场效果变量
bool isTransitioning = false;
unsigned long transitionStart = 0;
const unsigned long TRANSITION_DURATION = 1000;
int oldColors[3];
int newColors[3];

// HSV转RGB颜色转换
void hsvToRgb(float h, float s, float v, int* r, int* g, int* b) {
  float c = v * s;
  float x = c * (1 - abs(fmod(h / 60.0, 2) - 1));
  float m = v - c;
  
  float rt, gt, bt;
  if(h >= 0 && h < 60) {
    rt = c; gt = x; bt = 0;
  } else if(h >= 60 && h < 120) {
    rt = x; gt = c; bt = 0;
  } else if(h >= 120 && h < 180) {
    rt = 0; gt = c; bt = x;
  } else if(h >= 180 && h < 240) {
    rt = 0; gt = x; bt = c;
  } else if(h >= 240 && h < 300) {
    rt = x; gt = 0; bt = c;
  } else {
    rt = c; gt = 0; bt = x;
  }
  
  *r = (rt + m) * 255;
  *g = (gt + m) * 255;
  *b = (bt + m) * 255;
}

// 检查是否是特殊节日
bool checkHoliday(int& index) {
  for(int i = 0; i < sizeof(HOLIDAYS)/sizeof(HOLIDAYS[0]); i++) {
    if(HOLIDAYS[i].month == rtc.month && HOLIDAYS[i].day == rtc.day) {
      index = i;
      return true;
    }
  }
  return false;
}
// New function to handle advanced hourly effects
void handleAdvancedHourlyEffect() {
    unsigned long currentMillis = millis();
    
    if (!isHourlyEffect || !currentHourlyEffect) {
        restoreOriginalChars();
        return;
    }
    
    unsigned long effectElapsed = currentMillis - hourlyEffectStart;
    if (effectElapsed >= currentHourlyEffect->duration) {
        isHourlyEffect = false;
        restoreOriginalChars();
        return;
    }
    
    float progress = (float)effectElapsed / currentHourlyEffect->duration;
    int frame = (int)(progress * 8) % 8;
    uint8_t tempPattern[8];
    
    // 只使用4-7号位置存储特效动画
    switch(currentHourlyEffect->type) {
        case 0: // Spiral effect
            for(int i = 0; i < 4; i++) {
                memcpy(tempPattern, currentHourlyEffect->patterns[(frame + i) % 8], 8);
                lcd.customSymbol(i + 4, tempPattern); // 使用4-7号位置
            }
            break;
            
        case 1: // Pulsing effect
            for(int i = 0; i < 4; i++) {
                memcpy(tempPattern, currentHourlyEffect->patterns[(frame + i) % 8], 8);
                lcd.customSymbol(i + 4, tempPattern); // 使用4-7号位置
            }
            break;
            
        case 2: // Wave effect
            for(int i = 0; i < 4; i++) {
                memcpy(tempPattern, currentHourlyEffect->patterns[(frame + i) % 8], 8);
                lcd.customSymbol(i + 4, tempPattern); // 使用4-7号位置
            }
            break;
            
        case 3: // Twinkling effect
            for(int i = 0; i < 4; i++) {
                if(random(100) < 20) { // 20% chance to twinkle
                    memcpy(tempPattern, currentHourlyEffect->patterns[random(8)], 8);
                    lcd.customSymbol(i + 4, tempPattern); // 使用4-7号位置
                }
            }
            break;
    }
    
    // 移除 lcd.write(byte(0)); 以防止重复显示时钟图标
    // lcd.write(byte(0));  // 删除这一行
    
    lcd.setCursor(2, 0);
    lcd.printf("%02d:%02d:%02d", rtc.hour, rtc.minute, rtc.second);
    
    // 在剩余空间显示特效
    for(int i = 0; i < 4; i++) {
        lcd.setCursor(12 + (i % 2), i / 2);
        lcd.write(byte(4 + i));
    }
    
    // 设置特效颜色，确保颜色索引在有效范围内
    int colorIndex = frame % 8;
    setColor(
        currentHourlyEffect->colors[colorIndex][0],
        currentHourlyEffect->colors[colorIndex][1],
        currentHourlyEffect->colors[colorIndex][2],
        0.5 + sin(progress * PI * 2) * 0.5
    );
}
// 处理天气效果
void handleWeatherEffect(unsigned long currentMillis) {
  float temp = environment.getTemperature(TEMP_C);
  float humidity = environment.getHumidity();
  
  // 根据温度调整色相
  tempHue = map(temp, 0, 40, 240, 0); // 冷色到暖色
  
  // 根据湿度调整饱和度
  float saturation = map(humidity, 0, 100, 0.3, 1.0);
  
  int r, g, b;
  hsvToRgb(tempHue, saturation, 1.0, &r, &g, &b);
  
  // 添加波浪效果
  float wave = sin(currentMillis * 0.001 + tempOffset) * 0.2 + 0.8;
  setColor(r, g, b, wave);
  
  tempOffset += 0.1;
}

// 处理颜色转场效果
void handleTransition(unsigned long currentMillis) {
  if(!isTransitioning) return;
  
  float progress = (float)(currentMillis - transitionStart) / TRANSITION_DURATION;
  if(progress >= 1.0) {
    isTransitioning = false;
    return;
  }
  
  // 使用缓动函数使过渡更平滑
  progress = 0.5 - cos(progress * PI) / 2;
  
  int r = oldColors[0] + (newColors[0] - oldColors[0]) * progress;
  int g = oldColors[1] + (newColors[1] - oldColors[1]) * progress;
  int b = oldColors[2] + (newColors[2] - oldColors[2]) * progress;
  
  setColor(r, g, b, breatheValue);
}

// 修改 handleHourlyEffect 函数，提高特效的可见性
void handleHourlyEffect(unsigned long currentMillis) {
    if (!isHourlyEffect || !currentHourlyEffect) {
        restoreOriginalChars();
        return;
    }
    
    unsigned long effectElapsed = currentMillis - hourlyEffectStart;
    if (effectElapsed >= currentHourlyEffect->duration) {
        isHourlyEffect = false;
        restoreOriginalChars();
        return;
    }
    
    // 增加动画更新频率
    if (currentMillis - lastFrameUpdate >= 50) {  // 降低更新间隔到50ms
        lastFrameUpdate = currentMillis;
        hourlyEffectFrame = (hourlyEffectFrame + 1) % 8;
        
        // 更新特效动画字符
        for (int i = 0; i < 4; i++) {
            uint8_t tempPattern[8];
            memcpy(tempPattern, currentHourlyEffect->patterns[(hourlyEffectFrame + i) % 8], 8);
            lcd.customSymbol(i + 4, tempPattern);
        }
    }
    
    // 清屏并重新显示内容
    lcd.clear();
    
    // 显示时间（保持基本显示）
    lcd.setCursor(0, 0);
    lcd.write(byte(0));  // 时钟图标
    lcd.setCursor(2, 0);
    lcd.printf("%02d:%02d:%02d", rtc.hour, rtc.minute, rtc.second);
    
    // 在右侧显示特效动画
    for(int i = 0; i < 4; i++) {
        lcd.setCursor(12 + (i % 2), i / 2);
        lcd.write(byte(4 + i));
    }
    
    // 增强特效颜色变化
    float progress = (float)effectElapsed / currentHourlyEffect->duration;
    int colorIndex = hourlyEffectFrame % 8;
    float intensity = 0.5 + 0.5 * sin(progress * PI * 4);  // 加快颜色变化
    
    setColor(
        currentHourlyEffect->colors[colorIndex][0],
        currentHourlyEffect->colors[colorIndex][1],
        currentHourlyEffect->colors[colorIndex][2],
        intensity
    );
}

// 添加获取当前时间的处理函数
void handleGetTime() {
    server.send(200, "text/plain", cachedTimeStr);
}

// 添加保存WiFi设置的处理函数
void handleSaveWifi() {
  String ssid = server.arg("ssid");
  String password = server.arg("password");
  
  // 这里可以将WiFi凭据保存到EEPROM或其他存储中
  // TODO: 实现WiFi凭据的持久化存储
  
  server.send(200, "text/plain", "WiFi settings saved");
}

// 添加WiFi扫描处理函数
void handleScanWiFi() {
  int n = WiFi.scanNetworks();
  String json = "[";
  for (int i = 0; i < n; ++i) {
    if (i > 0) json += ",";
    json += "{\"ssid\":\"" + WiFi.SSID(i) + "\",\"rssi\":" + String(WiFi.RSSI(i)) + "}";
  }
  json += "]";
  server.send(200, "application/json", json);
}

// 添加WiFi连接处理函数
void handleConnectWiFi() {
  String ssid = server.arg("ssid");
  String password = server.arg("password");
  
  // 保存当前的WiFi模式
  WiFiMode_t currentMode = WiFi.getMode();
  
  // 切换到STA模式并尝试连接
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid.c_str(), password.c_str());
  
  // 等待连接，最多等待10秒
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    // 连接成功，尝试同步时间
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
      // 更新RTC时间
      rtc.adjustRtc(timeinfo.tm_year + 1900, 
                    timeinfo.tm_mon + 1,
                    timeinfo.tm_mday,
                    timeinfo.tm_wday,
                    timeinfo.tm_hour,
                    timeinfo.tm_min,
                    timeinfo.tm_sec);
      server.send(200, "text/plain", "success");
    } else {
      server.send(200, "text/plain", "Connected but time sync failed");
    }
  } else {
    server.send(500, "text/plain", "Connection failed");
  }
  
  // 恢复之前的WiFi模式
  WiFi.mode(currentMode);
}

// 添加恢复原始字符的函数
void restoreOriginalChars() {
    lcd.customSymbol(0, originalChars[0]);
    lcd.customSymbol(1, originalChars[1]);
    lcd.customSymbol(2, originalChars[2]);
    lcd.customSymbol(3, originalChars[3]);
}

// 添加新的处理函数
void handleSetColor() {
    if (!server.hasArg("plain")) {
        server.send(400, "application/json", "{\"status\":\"error\",\"message\":\"No data\"}");
        return;
    }
    
    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, server.arg("plain"));
    
    if (error) {
        server.send(400, "application/json", "{\"status\":\"error\",\"message\":\"Invalid JSON\"}");
        return;
    }
    
    // 立即保存颜色值，但在主循环中应用
    pendingColors[0] = constrain(doc["r"].as<int>(), 0, 255);
    pendingColors[1] = constrain(doc["g"].as<int>(), 0, 255);
    pendingColors[2] = constrain(doc["b"].as<int>(), 0, 255);
    colorNeedsUpdate = true;
    
    // 快速响应
    server.send(200, "application/json", "{\"status\":\"success\"}");
}

// 在全局变量区域添加
int lastHour = -1;  // 用于追踪上一次更新主题的小时

// 在全局变量区域添加新的呼吸速度和深度变量
float breatheSpeed = 0.001;  // 呼吸速度
float breatheDepth = 0.5;    // 呼吸深度，范围从0.1到1.0
unsigned long lastBreatheAdjustTime = 0;
const unsigned long BREATHE_ADJUST_INTERVAL = 5000; // 每5秒调整一次呼吸参数

// 在全局变量区域添加开机动画相关的字符定义
byte heart[8] = {
    0b00000,
    0b01010,
    0b11111,
    0b11111,
    0b11111,
    0b01110,
    0b00100,
    0b00000
};

byte smiley[8] = {
    0b00000,
    0b00000,
    0b01010,
    0b00000,
    0b00000,
    0b10001,
    0b01110,
    0b00000
};

byte frownie[8] = {
    0b00000,
    0b00000,
    0b01010,
    0b00000,
    0b00000,
    0b00000,
    0b01110,
    0b10001
};

byte armsDown[8] = {
    0b00100,
    0b01010,
    0b00100,
    0b00100,
    0b01110,
    0b10101,
    0b00100,
    0b01010
};

byte armsUp[8] = {
    0b00100,
    0b01010,
    0b00100,
    0b10101,
    0b01110,
    0b00100,
    0b00100,
    0b01010
};

// 添加开机动画函数
void playBootAnimation() {
    // 设置初始背光颜色为温暖的白色
    setColor(255, 255, 200, 1.0);
    
    // 临时保存当前自定义字符
    byte tempChars[5][8];
    for(int i = 0; i < 5; i++) {
        memcpy(tempChars[i], originalChars[i], 8);
    }
    
    // 设置动画字符
    lcd.customSymbol(0, heart);
    lcd.customSymbol(1, smiley);
    lcd.customSymbol(2, frownie);
    lcd.customSymbol(3, armsDown);
    lcd.customSymbol(4, armsUp);
    
    // 第一阶段：显示欢迎信息（淡蓝色）
    setColor(100, 200, 255, 1.0);
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Welcome to");
    lcd.setCursor(0, 1);
    lcd.print("Smart Clock ");
    lcd.write((unsigned char)1);
    delay(1000);
    
    // 第二阶段：心跳动画（粉红色）
    setColor(255, 100, 100, 1.0);
    for(int i = 0; i < 3; i++) {
        lcd.clear();
        lcd.setCursor(7, 0);
        lcd.write((unsigned char)0);
        setColor(255, 50, 50, 1.0);
        delay(300);
        lcd.clear();
        lcd.setCursor(7, 0);
        lcd.print(" ");
        setColor(255, 150, 150, 1.0);
        delay(200);
    }
    
    // 第三阶段：小人动画（渐变色）
    lcd.clear();
    lcd.setCursor(4, 0);
    lcd.print("Loading...");
    for(int i = 0; i < 4; i++) {
        float progress = i / 4.0;
        setColor(
            100 + progress * 155,  // 从淡蓝到白色渐变
            200,
            255 - progress * 55,
            1.0
        );
        lcd.setCursor(7, 1);
        lcd.write(3);
        delay(300);
        lcd.setCursor(7, 1);
        lcd.write(4);
        delay(300);
    }
    
    // 最后阶段：完成动画（明亮的白色）
    setColor(255, 255, 255, 1.0);
    lcd.clear();
    lcd.setCursor(3, 0);
    lcd.print("Ready! ");
    lcd.write((unsigned char)1);
    delay(1000);
    
    // 恢复原始自定义字符
    for(int i = 0; i < 5; i++) {
        lcd.customSymbol(i, tempChars[i]);
    }
    
    // 在清屏之前，确保设置一个过渡颜色
    setColor(currentThemeColors[0][0], 
            currentThemeColors[0][1], 
            currentThemeColors[0][2], 
            1.0);
            
    lcd.clear();
    
    // 初始化颜色相关变量，确保平滑过渡到正常显示
    breatheValue = 1.0;
    currentBrightness = 1.0;
    lastColorChange = millis();
    lastColorUpdate = millis();
    lastBreatheAdjustTime = millis();
    lastHueUpdate = millis();
    
    // 强制更新显示
    displayTime();
}

// 修改 setup 函数
void setup() {
    Serial.begin(115200);
    
    lcd.init();
    lcd.clear();
    
    // 保存原始字符
    lcd.customSymbol(0, clockChar);
    memcpy(originalChars[0], clockChar, 8);
    
    lcd.customSymbol(1, thermometer);
    memcpy(originalChars[1], thermometer, 8);
    
    lcd.customSymbol(2, humidityChar);
    memcpy(originalChars[2], humidityChar, 8);
    
    lcd.customSymbol(3, lightChar);
    memcpy(originalChars[3], lightChar, 8);
    
    // 初始化RTC和环境传感器
    rtc.setup();
    rtc.read();
    updateThemeColors(rtc.hour);  // 确保在播放动画前更新主题颜色
    
    while(environment.begin() != 0) {
        setColor(255, 50, 50, 1.0);  // 错误状态显示红色
        lcd.clear();
        lcd.print("Sensor Error!");
        delay(1000);
    }
    
    // 初始化其他变量
    forceTimeDisplay = false;
    randomSeed(analogRead(0));
    colorDuration = random(1000, 10000);
    
    // 设置动画帧
    for(int i = 0; i < 4; i++) {
        lcd.customSymbol(4 + i, animationFrames[rtc.week][i]);
    }
    
    // 播放开机动画
    playBootAnimation();
    
    // 设置网络
    setupAP();
    
    // 配置服务器路由
    server.on("/time", HTTP_GET, handleGetTime);
    server.on("/savewifi", HTTP_POST, handleSaveWifi);
    server.on("/advance-hourly-effect", HTTP_GET, handleAdvancedHourlyEffect);
    server.on("/set-color", HTTP_POST, handleSetColor);
    
    // 确保所有时间戳都被正确初始化
    lastUpdate = millis();
    lastEnvUpdate = millis();
    lastWebUpdate = millis();
    lastTimeUpdate = millis();
}

// 添加新的全局变量用于流光渐变
float currentHue = 0.0;         // 当前色相值 (0-360)
float hueSpeed = 0.5;          // 色相变化速度
float saturation = 1.0;        // 饱和度
float value = 1.0;             // 明度

const unsigned long HUE_UPDATE_INTERVAL = 20; // 每20ms更新一次色相

// 在全局变量区域添加HSV转RGB的函数
void hsvToRgb(float h, float s, float v, int& r, int& g, int& b) {
    float c = v * s;
    float x = c * (1 - abs(fmod(h / 60.0, 2) - 1));
    float m = v - c;
    
    float rf, gf, bf;
    if(h >= 0 && h < 60) {
        rf = c; gf = x; bf = 0;
    } else if(h >= 60 && h < 120) {
        rf = x; gf = c; bf = 0;
    } else if(h >= 120 && h < 180) {
        rf = 0; gf = c; bf = x;
    } else if(h >= 180 && h < 240) {
        rf = 0; gf = x; bf = c;
    } else if(h >= 240 && h < 300) {
        rf = x; gf = 0; bf = c;
    } else {
        rf = c; gf = 0; bf = x;
    }
    
    r = (rf + m) * 255;
    g = (gf + m) * 255;
    b = (bf + m) * 255;
}

void loop() {
    unsigned long currentMillis = millis();
    
    // 更新缓存的时间字符串
    if (currentMillis - lastTimeUpdate >= 1000) {  // 每秒更新一次
        rtc.read();
        snprintf(cachedTimeStr, sizeof(cachedTimeStr), "%02d:%02d:%02d", 
                rtc.hour, rtc.minute, rtc.second);
        lastTimeUpdate = currentMillis;
    }
    
    // 优先处理 Web 服务器请求
    dnsServer.processNextRequest();
    server.handleClient();
    
    // 处理颜色更新
    if (colorNeedsUpdate && (currentMillis - lastColorUpdate >= COLOR_UPDATE_INTERVAL)) {
        isManualColorControl = true;
        lastColorControlTime = currentMillis;
        
        manualColors[0] = pendingColors[0];
        manualColors[1] = pendingColors[1];
        manualColors[2] = pendingColors[2];
        
        setColor(manualColors[0], manualColors[1], manualColors[2], MANUAL_MODE_BRIGHTNESS);
        
        lastColorUpdate = currentMillis;
        colorNeedsUpdate = false;
    }
    
    // 修改环境更新和显示逻辑
    if (currentMillis - lastEnvUpdate >= ENV_UPDATE_INTERVAL) {
        lastEnvUpdate = currentMillis;
        rtc.read();
        
        // 添加主题颜色更新检查
        if (rtc.hour != lastHour) {
            updateThemeColors(rtc.hour);
            lastHour = rtc.hour;
            
            // 如果不在手动控制模式，立即开始向新主题颜色过渡
            if (!isManualColorControl) {
                memcpy(oldColors, currentThemeColors[currentColor], sizeof(oldColors));
                currentColor = 0;  // 重置为新主题的第一个颜色
                memcpy(newColors, currentThemeColors[currentColor], sizeof(newColors));
                isTransitioning = true;
                transitionStart = currentMillis;
                lastColorChange = currentMillis;
            }
        }
        
        // 只在非整点特效时处理显示逻辑
        if (!isHourlyEffect) {
            if (showTimeMode && !forceTimeDisplay) {
                if (random(100) < (ENV_DISPLAY_PROBABILITY * 100)) {
                    showTimeMode = false;
                    envDisplayStartTime = currentMillis;
                    scrollPosition = 0;
        envDataString = "";
        lastScrollTime = currentMillis;
                }
            } else if (!showTimeMode) {
                if (currentMillis - envDisplayStartTime >= ENV_DISPLAY_DURATION) {
                    showTimeMode = true;
                }
            }
            
            // 清除屏幕以防止内容重叠
            lcd.clear();
            
            if (showTimeMode) {
                displayTime();
            } else {
                displayEnvironmental();
            }
        } else {
            // 如���是整点特效，调用整点特效处理函数
            handleHourlyEffect(currentMillis);
        }
        
        adjustBrightness();
    }
    
    // Web 界面更新
    if (currentMillis - lastWebUpdate >= WEB_UPDATE_INTERVAL) {
        lastWebUpdate = currentMillis;
        // 可以在这里添加其他需要频繁更新的 Web 相关操作
    }
    
    // 检查手动控制是否超时
    if (isManualColorControl && (currentMillis - lastColorControlTime >= COLOR_CONTROL_TIMEOUT)) {
        Serial.println("Manual control timeout, returning to auto mode");
        isManualColorControl = false;
        // 平滑过渡回自动模式
        memcpy(oldColors, manualColors, sizeof(oldColors));
        memcpy(newColors, currentThemeColors[currentColor], sizeof(newColors));
        isTransitioning = true;
        transitionStart = currentMillis;
    }

    // 颜色���制逻辑
    if (isManualColorControl) {
        // 手动控制模式下只更新颜色，不影响显示内容
        setColor(manualColors[0], manualColors[1], manualColors[2], MANUAL_MODE_BRIGHTNESS);
    } else {
        // 自动模式下的特效和颜色渐变处理
        if (inSpecialEffect) {
            handleSpecialEffect(currentMillis);
        } else if (isWeatherEffect) {
            if (currentMillis - weatherEffectStart > WEATHER_EFFECT_DURATION) {
                isWeatherEffect = false;
            } else {
                handleWeatherEffect(currentMillis);
            }
        } else if (isTransitioning) {
            handleTransition(currentMillis);
        } else if (isHourlyEffect) {
            handleHourlyEffect(currentMillis);
        } else {
            // 在正常的颜色渐变和呼吸效果部分修改
            if (currentMillis - lastHueUpdate >= HUE_UPDATE_INTERVAL) {
                lastHueUpdate = currentMillis;
                
                // 更新色相值
                currentHue += hueSpeed;
                if (currentHue >= 360) {
                    currentHue = 0;
                }
                
                // 计算呼吸效果
                float breatheProgress = (sin(currentMillis * breatheSpeed) + 1.0) / 2.0;
                breatheValue = BREATHE_MIN + (BREATHE_MAX - BREATHE_MIN) * breatheProgress * breatheDepth;
                
                // 将HSV转换为RGB
                int r, g, b;
                // 根据时间段调整饱和度和明度
                if (rtc.hour >= 22 || rtc.hour < 6) {
                    // 夜间降低饱和度和明度
                    saturation = 0.7;
                    value = 0.6;
                } else if (rtc.hour >= 6 && rtc.hour < 9) {
                    // 早晨逐渐提高饱和度和明度
                    saturation = 0.8;
                    value = 0.8;
                } else {
                    // 白天保持正常饱和度和明度
                    saturation = 1.0;
                    value = 1.0;
                }
                
                hsvToRgb(currentHue, saturation, value, r, g, b);
                
                // 应用颜色和呼吸效果
                setColor(r, g, b, breatheValue);
            }
            
            // 每隔一段时间随机调整呼吸和流光参数
            if (currentMillis - lastBreatheAdjustTime > BREATHE_ADJUST_INTERVAL) {
                lastBreatheAdjustTime = currentMillis;
                breatheSpeed = random(5, 15) / 10000.0;
                breatheDepth = random(5, 10) / 10.0;
                
                // 随机调整色相变化速度
                hueSpeed = random(3, 10) / 10.0; // 0.3 到 1.0 之间
            }
        }
    }

    // 时间同步检查
    if (currentMillis - lastSyncAttempt >= SYNC_INTERVAL) {
        timeNeedSync = true;
        lastSyncAttempt = currentMillis;
    }
    
    if (timeNeedSync && syncTimeFromNTP()) {
        timeNeedSync = false;
    }
    
    // 调用高级整点特效处理函数
    handleAdvancedHourlyEffect();
}
