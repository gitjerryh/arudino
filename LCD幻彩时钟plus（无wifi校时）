#include <Wire.h>
#include "GravityRtc.h"
#include "DFRobot_RGBLCD1602.h"
#include "DFRobot_EnvironmentalSensor.h"

GravityRtc rtc;
DFRobot_RGBLCD1602 lcd(0x2D, 16, 2);
DFRobot_EnvironmentalSensor environment(SEN050X_DEFAULT_DEVICE_ADDRESS, &Wire);

const char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
const char* dayNames[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

unsigned long lastUpdate = 0;
unsigned long lastColorChange = 0;
unsigned long lastEnvUpdate = 0;
unsigned long colorDuration = 0;
unsigned long specialEffectStart = 0;
const unsigned long ENV_UPDATE_INTERVAL = 1000;
bool showTimeMode = true;

int currentColor = 0;
float breatheValue = 0;
bool breatheIncreasing = true;
bool inSpecialEffect = false;
int specialEffectStep = 0;
float lastTemp = 0.0;  // 在全局变量区域添加这个变量
// Custom characters
byte clockChar[8] = {
  B00000, B01110, B10101, B10111,
  B10001, B01110, B00000, B00000
};

byte thermometer[8] = {
  B00100, B01010, B01010, B01110,
  B01110, B11111, B11111, B01110
};

byte humidityChar[8] = {
  B00100, B00100, B01110, B01110,
  B11111, B11111, B01110, B00000
};

byte lightChar[8] = {
  B00000, B10101, B01110, B11111,
  B01110, B10101, B00000, B00000
};

// Color themes
const int MORNING_COLORS[][3] = {
  {255, 200, 100}, {255, 150, 50},
  {255, 180, 120}, {200, 150, 100}
};

const int DAY_COLORS[][3] = {
  {100, 200, 255}, {150, 255, 200},
  {255, 255, 200}, {200, 255, 255}
};

const int EVENING_COLORS[][3] = {
  {255, 100, 100}, {255, 150, 50},
  {200, 100, 150}, {150, 100, 200}
};

const int NIGHT_COLORS[][3] = {
  {50, 50, 150}, {100, 50, 150},
  {50, 100, 150}, {100, 100, 200}
};

const int SPECIAL_COLORS[][3] = {
  {255, 255, 255}, {255, 255, 0},
  {255, 0, 0}, {0, 255, 0}, {0, 0, 255}
};

int currentThemeColors[4][3];
int numThemeColors = 4;

// 为每个星期设计不同的动画图案
byte animationFrames[7][4][8] = {
  // 星期日 - 太阳动画
  {
    {B00000,B00100,B10101,B01110,B11111,B01110,B10101,B00100},
    {B00100,B10101,B01110,B11111,B01110,B10101,B00100,B00000},
    {B10101,B01110,B11111,B01110,B10101,B00100,B00000,B00100},
    {B01110,B11111,B01110,B10101,B00100,B00000,B00100,B10101}
  },
  // 星期一 - 月亮动画
  {
    {B00000,B00111,B01111,B01111,B01111,B01111,B00111,B00000},
    {B00000,B01110,B11111,B11111,B11111,B11111,B01110,B00000},
    {B00000,B11100,B11110,B11110,B11110,B11110,B11100,B00000},
    {B00000,B01110,B11111,B11111,B11111,B11111,B01110,B00000}
  },
  // 星期二 - 雨滴动画
  {
    {B00000,B00100,B01110,B11111,B00000,B00100,B01110,B11111},
    {B00100,B01110,B11111,B00000,B00100,B01110,B11111,B00000},
    {B01110,B11111,B00000,B00100,B01110,B11111,B00000,B00100},
    {B11111,B00000,B00100,B01110,B11111,B00000,B00100,B01110}
  },
  // 星期三 - 星星动画
  {
    {B00000,B00100,B01110,B11111,B01110,B10101,B01010,B00000},
    {B00100,B01110,B11111,B01110,B10101,B01010,B00000,B00000},
    {B01110,B11111,B01110,B10101,B01010,B00000,B00100,B00000},
    {B11111,B01110,B10101,B01010,B00000,B00100,B01110,B00000}
  },
  // 星期四 - 心跳动画
  {
    {B00000,B01010,B11111,B11111,B01110,B00100,B00000,B00000},
    {B01010,B11111,B11111,B01110,B00100,B00000,B00000,B00000},
    {B11111,B11111,B01110,B00100,B00000,B00000,B01010,B00000},
    {B11111,B01110,B00100,B00000,B00000,B01010,B11111,B00000}
  },
  // 星期五 - 音符动画
  {
    {B00100,B00110,B00101,B00100,B01100,B11100,B11100,B00000},
    {B00110,B00101,B00100,B01100,B11100,B11100,B00000,B00100},
    {B00101,B00100,B01100,B11100,B11100,B00000,B00100,B00110},
    {B00100,B01100,B11100,B11100,B00000,B00100,B00110,B00101}
  },
  // 星期六 - 花朵动画
  {
    {B00000,B01010,B11111,B11111,B01110,B00100,B00000,B00000},
    {B01010,B11111,B11111,B01110,B00100,B00000,B01010,B00000},
    {B11111,B11111,B01110,B00100,B00000,B01010,B11111,B00000},
    {B11111,B01110,B00100,B00000,B01010,B11111,B11111,B00000}
  }
};

int currentFrame = 0;
unsigned long lastFrameUpdate = 0;
const unsigned long FRAME_INTERVAL = 300; // 动画帧更新间隔

// 添加亮度控制相关的常量
const int MIN_LIGHT = 0;    // 最小光照强度（lux）
const int MAX_LIGHT = 1000; // 最大光照强度（lux）
const float MIN_BRIGHTNESS = 0.2; // 最小亮度比例
const float MAX_BRIGHTNESS = 1.0; // 最大亮度比例
float currentBrightness = MAX_BRIGHTNESS;

void setColor(int r, int g, int b, float intensity) {
  intensity *= currentBrightness; // 应用全局亮度设置
  lcd.setPWM(lcd.REG_RED, r * intensity);
  lcd.setPWM(lcd.REG_GREEN, g * intensity);
  lcd.setPWM(lcd.REG_BLUE, b * intensity);
}

void adjustBrightness() {
  int lightIntensity = environment.getLuminousIntensity();
  
  // 将光照强度限制在有效范围内
  lightIntensity = constrain(lightIntensity, MIN_LIGHT, MAX_LIGHT);
  
  // 使用映射函数计算亮度
  currentBrightness = MIN_BRIGHTNESS + 
    (MAX_BRIGHTNESS - MIN_BRIGHTNESS) * 
    (float)(lightIntensity - MIN_LIGHT) / (MAX_LIGHT - MIN_LIGHT);
    
  // 使用指数曲线使亮度变化更自然
  currentBrightness = pow(currentBrightness, 0.5);
}

void updateThemeColors(int hour) {
  if (hour >= 6 && hour < 11) {
    memcpy(currentThemeColors, MORNING_COLORS, sizeof(MORNING_COLORS));
  } else if (hour >= 11 && hour < 17) {
    memcpy(currentThemeColors, DAY_COLORS, sizeof(DAY_COLORS));
  } else if (hour >= 17 && hour < 20) {
    memcpy(currentThemeColors, EVENING_COLORS, sizeof(EVENING_COLORS));
  } else {
    memcpy(currentThemeColors, NIGHT_COLORS, sizeof(NIGHT_COLORS));
  }
}

void handleSpecialEffect(unsigned long currentMillis) {
  if (!inSpecialEffect) return;
  
  const int effectDuration = 3000;
  unsigned long elapsedTime = currentMillis - specialEffectStart;
  
  if (elapsedTime > effectDuration) {
    inSpecialEffect = false;
    return;
  }

  int step = (elapsedTime / 200) % 5;
  setColor(
    SPECIAL_COLORS[step][0],
    SPECIAL_COLORS[step][1],
    SPECIAL_COLORS[step][2],
    1.0
  );
}

void displayTime() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - lastFrameUpdate >= FRAME_INTERVAL) {
    lastFrameUpdate = currentMillis;
    currentFrame = (currentFrame + 1) % 4;
    
    // 更新动画字符
    for(int i = 0; i < 4; i++) {
      lcd.customSymbol(4 + i, animationFrames[rtc.week][(currentFrame + i) % 4]);
    }
  }
  
  lcd.clear();
  lcd.write(byte(0));  // 时钟图标
  
  // 显示时间
  lcd.setCursor(2, 0);
  lcd.printf("%02d:%02d:%02d", rtc.hour, rtc.minute, rtc.second);
  
  // 在第一行右侧显示动画
  lcd.setCursor(12, 0);
  lcd.write(byte(4));
  lcd.write(byte(5));
  
  // 显示日期和星期
  lcd.setCursor(0, 1);
  lcd.printf("%s %02d %s", monthNames[rtc.month-1], rtc.day, dayNames[rtc.week]);
  
  // 在第二行右侧显示动画
  lcd.setCursor(12, 1);
  lcd.write(byte(6));
  lcd.write(byte(7));
}

void displayEnvironmental() {
  lcd.clear();
  lcd.write(byte(1));
  lcd.printf(" %.1fC ", environment.getTemperature(TEMP_C));
  lcd.write(byte(2));
  lcd.printf(" %d%%", (int)environment.getHumidity());
  
  lcd.setCursor(0, 1);
  lcd.write(byte(3));
  lcd.printf(" %d lx", (int)environment.getLuminousIntensity());
}

const struct {
  int month;
  int day;
  const char* name;
  const int colors[5][3];
} HOLIDAYS[] = {
  {1, 1, "New Year", {{255,0,0}, {255,215,0}, {255,255,255}, {255,192,203}, {255,69,0}}},
  {12, 25, "Christmas", {{255,0,0}, {0,255,0}, {255,255,255}, {255,215,0}, {0,128,0}}},
  // 可以添加更多节日
};

// 新增天气效果相关变量
float tempHue = 0.0;
float tempOffset = 0.0;
bool isWeatherEffect = false;
unsigned long weatherEffectStart = 0;
const unsigned long WEATHER_EFFECT_DURATION = 5000;

// 新增转场效果变量
bool isTransitioning = false;
unsigned long transitionStart = 0;
const unsigned long TRANSITION_DURATION = 1000;
int oldColors[3];
int newColors[3];

// 添加以下新函数

// HSV转RGB颜色转换
void hsvToRgb(float h, float s, float v, int* r, int* g, int* b) {
  float c = v * s;
  float x = c * (1 - abs(fmod(h / 60.0, 2) - 1));
  float m = v - c;
  
  float rt, gt, bt;
  if(h >= 0 && h < 60) {
    rt = c; gt = x; bt = 0;
  } else if(h >= 60 && h < 120) {
    rt = x; gt = c; bt = 0;
  } else if(h >= 120 && h < 180) {
    rt = 0; gt = c; bt = x;
  } else if(h >= 180 && h < 240) {
    rt = 0; gt = x; bt = c;
  } else if(h >= 240 && h < 300) {
    rt = x; gt = 0; bt = c;
  } else {
    rt = c; gt = 0; bt = x;
  }
  
  *r = (rt + m) * 255;
  *g = (gt + m) * 255;
  *b = (bt + m) * 255;
}

// 检查是否是特殊节日
bool checkHoliday(int& index) {
  for(int i = 0; i < sizeof(HOLIDAYS)/sizeof(HOLIDAYS[0]); i++) {
    if(HOLIDAYS[i].month == rtc.month && HOLIDAYS[i].day == rtc.day) {
      index = i;
      return true;
    }
  }
  return false;
}

// 处理天气效果
void handleWeatherEffect(unsigned long currentMillis) {
  float temp = environment.getTemperature(TEMP_C);
  float humidity = environment.getHumidity();
  
  // 根据温度调整色相
  tempHue = map(temp, 0, 40, 240, 0); // 冷色到暖色
  
  // 根据湿度调整饱和度
  float saturation = map(humidity, 0, 100, 0.3, 1.0);
  
  int r, g, b;
  hsvToRgb(tempHue, saturation, 1.0, &r, &g, &b);
  
  // 添加波浪效果
  float wave = sin(currentMillis * 0.001 + tempOffset) * 0.2 + 0.8;
  setColor(r, g, b, wave);
  
  tempOffset += 0.1;
}

// 处理颜色转场效果
void handleTransition(unsigned long currentMillis) {
  if(!isTransitioning) return;
  
  float progress = (float)(currentMillis - transitionStart) / TRANSITION_DURATION;
  if(progress >= 1.0) {
    isTransitioning = false;
    return;
  }
  
  // 使用缓动函数使过渡更平滑
  progress = 0.5 - cos(progress * PI) / 2;
  
  int r = oldColors[0] + (newColors[0] - oldColors[0]) * progress;
  int g = oldColors[1] + (newColors[1] - oldColors[1]) * progress;
  int b = oldColors[2] + (newColors[2] - oldColors[2]) * progress;
  
  setColor(r, g, b, breatheValue);
}

void setup() {
  Serial.begin(115200);
  
  lcd.init();
  lcd.clear();
  
  lcd.customSymbol(0, clockChar);
  lcd.customSymbol(1, thermometer);
  lcd.customSymbol(2, humidityChar);
  lcd.customSymbol(3, lightChar);
  
  rtc.setup();
  //rtc.adjustRtc(2024,10,24,4,14,28,10);
  
  while(environment.begin() != 0) {
    lcd.clear();
    lcd.print("Sensor Error!");
    delay(1000);
  }
  
  randomSeed(analogRead(0));
  colorDuration = random(3000, 10000);
  
  rtc.read();
  updateThemeColors(rtc.hour);
  for(int i = 0; i < 4; i++) {
    lcd.customSymbol(4 + i, animationFrames[rtc.week][i]);
  }
}

void loop() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - lastUpdate >= 10000) {
    showTimeMode = !showTimeMode;
    lastUpdate = currentMillis;
  }
  
  if (currentMillis - lastEnvUpdate >= ENV_UPDATE_INTERVAL) {
    lastEnvUpdate = currentMillis;
    rtc.read();
    
    // 检查是否是节日
    int holidayIndex;
    if(checkHoliday(holidayIndex)) {
      inSpecialEffect = true;
      specialEffectStart = currentMillis;
      memcpy(currentThemeColors, HOLIDAYS[holidayIndex].colors, sizeof(HOLIDAYS[holidayIndex].colors));
      numThemeColors = 5;
    } else {
      updateThemeColors(rtc.hour);
      numThemeColors = 4;
    }
    
    // 检查温度变化触发天气效果
    float temp = environment.getTemperature(TEMP_C);
    if(abs(temp - lastTemp) > 2.0) { // 温度变化超过2度
      isWeatherEffect = true;
      weatherEffectStart = currentMillis;
    }
    lastTemp = temp;
    
    adjustBrightness();
    
    if (showTimeMode) {
      displayTime();
    } else {
      displayEnvironmental();
    }
  }
  
  // 处理各种特效
  if (inSpecialEffect) {
    handleSpecialEffect(currentMillis);
    return;
  }
  
  if (isWeatherEffect) {
    if (currentMillis - weatherEffectStart > WEATHER_EFFECT_DURATION) {
      isWeatherEffect = false;
    } else {
      handleWeatherEffect(currentMillis);
      return;
    }
  }
  
  if (isTransitioning) {
    handleTransition(currentMillis);
    return;
  }
  
  // 颜色切换时启动转场效果
  if (currentMillis - lastColorChange >= colorDuration) {
    memcpy(oldColors, currentThemeColors[currentColor], sizeof(oldColors));
    currentColor = (currentColor + 1) % numThemeColors;
    memcpy(newColors, currentThemeColors[currentColor], sizeof(newColors));
    
    isTransitioning = true;
    transitionStart = currentMillis;
    lastColorChange = currentMillis;
    colorDuration = random(3000, 10000);
  }
  float breatheSpeed = 0.0005;
  if (breatheIncreasing) {
    breatheValue += breatheSpeed;
    if (breatheValue >= 1.0) {
      breatheValue = 1.0;
      breatheIncreasing = false;
    }
  } else {
    breatheValue -= breatheSpeed;
    if (breatheValue <= 0.3) {
      breatheValue = 0.3;
      breatheIncreasing = true;
    }
  }
  
  setColor(
    currentThemeColors[currentColor][0],
    currentThemeColors[currentColor][1],
    currentThemeColors[currentColor][2],
    breatheValue
  );
}
