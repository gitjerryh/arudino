#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
#include <WiFi.h>
#include <WebServer.h>
#include <SPIFFS.h>
#include <ArduinoJson.h>
#include <cmath>

// WiFi设置
const char* ssid = "RoboticArm";  // AP名称
const char* password = "12345678"; // AP密码

// 创建Web服务器对象
WebServer server(80);

// ESP32的I2C引脚定义
#define I2C_SDA 21
#define I2C_SCL 22

// 舵机参数定义
#define SERVOMIN  150 
#define SERVOMAX  600 
#define SERVO_FREQ 50 

// 定义舵机引脚
#define PIN_HAND        11
#define PIN_WRIST       12
#define PIN_ELBOW       13
#define PIN_SHOULDER    14
#define PIN_BASE        15

// 创建舵机通道数组
const uint8_t SERVO_PINS[] = {PIN_HAND, PIN_WRIST, PIN_ELBOW, PIN_SHOULDER, PIN_BASE};
const uint8_t SERVO_COUNT = sizeof(SERVO_PINS) / sizeof(SERVO_PINS[0]);

// 添加舵机名称数组，便于调试
const char* SERVO_NAMES[] = {"手部", "手腕", "肘部", "肩部", "底座"};

// 创建PWM驱动对象
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40);

// 添加速度控制参数
struct ServoConfig {
    uint8_t min;
    uint8_t max;
    uint8_t stepDelay;    // 每步延时(ms)
    float stepSize;       // 每次移动的角度
    float acceleration;   // 加速度参数
    float maxSpeed;       // 最大速度限制
    float startSpeed;     // 起始速度
};

// 为每个舵机定义具体参数
const ServoConfig SERVO_CONFIGS[] = {
    //min, max, delay, stepSize, accel, maxSpeed, startSpeed
    {0, 180, 15, 1.0, 0.02, 2.0, 0.5},    // 手部：提高速度和加速度
    {0, 180, 20, 0.8, 0.015, 1.5, 0.4},   // 手腕：降低速度提高稳定性
    {30, 150, 25, 0.6, 0.015, 1.2, 0.3},  // 肘部：保持原参数
    {30, 150, 20, 0.5, 0.015, 1.2, 0.3},  // 肩部：降低速度增加稳定性
    {0, 180, 25, 0.7, 0.02, 1.5, 0.4}     // 底座：保持原参数
};

// 运动状态和控制变量
volatile bool isMovingServos = false;
String currentMovingServo = "";
bool shouldCancelMovement = false;

// 添加运动控制变量
unsigned long lastMoveTime = 0;
const unsigned long MOVE_TIMEOUT = 10000;  // 增加到10秒
const unsigned long SHOULDER_MOVE_TIMEOUT = 15000;  // 肩部舵机专用超时时间

// 添加数据结构定义到全局区域
struct MoveData {
    float targets[5];
    float currents[5];
};

// 添加舵机安全限位和状态监控
struct ServoSafetyLimits {
    float minAngle;      // 最小安全角度
    float maxAngle;      // 最大安全角度
    float maxSpeed;      // 最大安全速度
    int16_t lastPWM;     // 上一次的PWM值
    uint32_t lastMoveTime; // 上一次移动时间
    bool isStuck;        // 卡死状态标志
};

// 为每个舵机创建安全限制
ServoSafetyLimits SERVO_LIMITS[] = {
    {0, 180, 1.5, -1, 0, false},    // 手部：降低最大速度限制
    {0, 180, 1.8, -1, 0, false},    // 手腕
    {30, 150, 1.2, -1, 0, false},   // 肘部
    {30, 150, 1.0, -1, 0, false},   // 肩部
    {0, 180, 1.5, -1, 0, false}     // 底座
};

// 修改PWM设置函数，添加安全检查
bool setPWMSafely(uint8_t servoIndex, uint16_t pwmValue) {
    // 检查PWM值是否在合理范围内
    if (pwmValue < SERVOMIN || pwmValue > SERVOMAX) {
        Serial.printf("警告: 舵机 %s PWM值 %d 超出范围!\n", SERVO_NAMES[servoIndex], pwmValue);
        return false;
    }
    
    // 手部舵机的特殊处理
    if (servoIndex == 0) {  // 手部舵机
        // 添加额外的PWM范围检查
        if (pwmValue < SERVOMIN + 50 || pwmValue > SERVOMAX - 50) {
            Serial.printf("手部舵机: PWM值 %d 接近极限，已调整\n", pwmValue);
            pwmValue = constrain(pwmValue, SERVOMIN + 50, SERVOMAX - 50);
        }
        
        if (SERVO_LIMITS[servoIndex].lastPWM != -1) {
            int16_t pwmChange = abs(pwmValue - SERVO_LIMITS[servoIndex].lastPWM);
            int16_t maxChange = 100;  // 减小最大变化量
            
            if (pwmChange > maxChange) {
                // 使用更保守的PWM调整
                int16_t adjustedChange = maxChange * 0.6;  // 更保守的调整
                if (pwmValue > SERVO_LIMITS[servoIndex].lastPWM) {
                    pwmValue = SERVO_LIMITS[servoIndex].lastPWM + adjustedChange;
                } else {
                    pwmValue = SERVO_LIMITS[servoIndex].lastPWM - adjustedChange;
                }
                Serial.printf("手部舵机PWM保守调整: %d (变化量: %d)\n", 
                    pwmValue, pwmChange);
            }
        }
        
        // 添加PWM累积效应检查
        static uint32_t lastResetTime = 0;
        static uint16_t lastStablePWM = 375;  // 中间位置
        
        if (millis() - lastResetTime > 5000) {  // 每5秒检查一次
            if (abs(pwmValue - lastStablePWM) > 200) {
                Serial.println("手部舵机: 检测到可能的累积效应，重置到稳定位置");
                pwmValue = lastStablePWM;
                SERVO_LIMITS[servoIndex].lastPWM = pwmValue;
            }
            lastResetTime = millis();
        }
    } else {
        // 其他舵机的现有处理逻辑...
    }
    
    // 更新状态并设置PWM
    SERVO_LIMITS[servoIndex].lastPWM = pwmValue;
    SERVO_LIMITS[servoIndex].lastMoveTime = millis();
    pwm.setPWM(SERVO_PINS[servoIndex], 0, pwmValue);
    return true;
}

// 修改角度转换函数，添加安全检查
uint16_t angleToPWM(uint8_t servoIndex, float angle) {
    // 检查角度是否在安全范围内
    if (angle < SERVO_LIMITS[servoIndex].minAngle || 
        angle > SERVO_LIMITS[servoIndex].maxAngle) {
        Serial.printf("警告: 舵机 %s 角度 %.1f 超出安全范围!\n", 
                     SERVO_NAMES[servoIndex], angle);
        return 0;
    }
    
    // 计算PWM值
    uint16_t pwm = map(angle, 0, 180, SERVOMIN, SERVOMAX);
    return pwm;
}

// 函数声明
float sCurveInterpolation(float start, float end, float t);
void moveServoSmooth(uint8_t servoIndex, float targetAngle, float currentAngle);
void returnToCenter();
void handleRoot();
void handleServo();
void handleSavePositions();
void handleLoadPositions();
void handleCenter();
void handleCancelMovement();
void handleResetServo();
void handleStatus();
void savePositionsToFlash(const char* positions);
String loadPositionsFromFlash();
void clearErrors();
void statusMonitorTask(void* parameter);
void handleEmergencyStop();
void calibrateServo(uint8_t servoIndex);

// HTML页面
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>机械臂控制系统</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            margin-bottom: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header h1 {
            font-size: 1.8rem;
            margin: 0;
        }
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 2rem;
        }
        .servo-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .servo-card h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        .slider-container {
            margin-bottom: 1rem;
        }
        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 4px;
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            transition: background .2s;
        }
        .slider::-webkit-slider-thumb:hover {
            background: #2980b9;
        }
        .value {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
            margin-top: 8px;
        }
        .preset-panel {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        .preset-btn {
            padding: 12px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .preset-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        .preset-btn.save { background: #27ae60; }
        .preset-btn.save:hover { background: #219a52; }
        .preset-btn.load { background: #e67e22; }
        .preset-btn.load:hover { background: #d35400; }
        
        .status-panel {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #2ecc71;
        }
        .status-dot.moving { background: #e74c3c; }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header { margin-bottom: 1rem; }
            .preset-buttons { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>机械臂控制系统</h1>
        </div>

        <div class="status-panel">
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="movement-status">系统就绪</span>
            </div>
            <span id="connection-status">已连接</span>
        </div>

        <div class="preset-panel">
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setPreset('home')">初始位置</button>
                <button class="preset-btn" onclick="setPreset('retract')">收缩位置</button>
                <button class="preset-btn save" onclick="saveCurrentPos()">保存位置</button>
                <button class="preset-btn load" onclick="loadSavedPos()">加载位置</button>
            </div>
        </div>

        <div class="control-panel">
            <div class="servo-card">
                <h3>手部舵机</h3>
                <div class="slider-container">
                    <input type="range" min="0" max="180" value="90" class="slider" id="hand" 
                           oninput="updateServo('hand', this.value)">
                    <div class="value" id="hand-value">90°</div>
                </div>
            </div>

            <div class="servo-card">
                <h3>手腕舵机</h3>
                <div class="slider-container">
                    <input type="range" min="0" max="180" value="90" class="slider" id="wrist"
                           oninput="updateServo('wrist', this.value)">
                    <div class="value" id="wrist-value">90°</div>
                </div>
            </div>

            <div class="servo-card">
                <h3>肘部舵机</h3>
                <div class="slider-container">
                    <input type="range" min="0" max="180" value="90" class="slider" id="elbow"
                           oninput="updateServo('elbow', this.value)">
                    <div class="value" id="elbow-value">90°</div>
                </div>
            </div>

            <div class="servo-card">
                <h3>肩部舵机</h3>
                <div class="slider-container">
                    <input type="range" min="0" max="180" value="90" class="slider" id="shoulder"
                           oninput="updateServo('shoulder', this.value)">
                    <div class="value" id="shoulder-value">90°</div>
                </div>
            </div>

            <div class="servo-card">
                <h3>底座舵机</h3>
                <div class="slider-container">
                    <input type="range" min="0" max="180" value="90" class="slider" id="base"
                           oninput="updateServo('base', this.value)">
                    <div class="value" id="base-value">90°</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let savedPositions = {};
        
        function updateServo(servo, angle) {
            document.getElementById(servo + '-value').innerHTML = angle + '°';
            var xhr = new XMLHttpRequest();
            var currentAngle = document.getElementById(servo).value;
            xhr.open('GET', `/servo?name=${servo}&angle=${angle}&current=${currentAngle}`, true);
            xhr.send();
            
            // 更新状态指示
            document.getElementById('status-dot').classList.add('moving');
            document.getElementById('movement-status').textContent = '正在移动: ' + 
                {'hand': '手部', 'wrist': '手腕', 'elbow': '肘部', 'shoulder': '肩部', 'base': '底座'}[servo];
            
            // 2秒后恢复状态
            setTimeout(() => {
                document.getElementById('status-dot').classList.remove('moving');
                document.getElementById('movement-status').textContent = '系统就绪';
            }, 2000);
        }
        
        function setPreset(preset) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', '/center?preset=' + preset, true);
            xhr.send();
            
            document.getElementById('status-dot').classList.add('moving');
            document.getElementById('movement-status').textContent = '正在回到' + 
                (preset === 'home' ? '初始' : '收缩') + '位置';
            
            setTimeout(() => {
                const servos = ['hand', 'wrist', 'elbow', 'shoulder', 'base'];
                const angles = preset === 'home' ? 
                    [90, 90, 90, 90, 90] : 
                    [154, 74, 150, 30, 90];
                    
                servos.forEach((servo, index) => {
                    document.getElementById(servo).value = angles[index];
                    document.getElementById(servo + '-value').innerHTML = angles[index] + '°';
                });
                document.getElementById('status-dot').classList.remove('moving');
                document.getElementById('movement-status').textContent = '系统就绪';
            }, 5000);
        }
        
        function saveCurrentPos() {
            savedPositions = {
                hand: document.getElementById('hand').value,
                wrist: document.getElementById('wrist').value,
                elbow: document.getElementById('elbow').value,
                shoulder: document.getElementById('shoulder').value,
                base: document.getElementById('base').value
            };
            
            fetch('/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(savedPositions)
            })
            .then(response => {
                if (response.ok) {
                    showNotification('位置已保存!', 'success');
                } else {
                    showNotification('保存失败!', 'error');
                }
            })
            .catch(error => {
                showNotification('保存错误: ' + error, 'error');
            });
        }
        
        function loadSavedPos() {
            fetch('/load')
            .then(response => response.json())
            .then(positions => {
                if (Object.keys(positions).length === 0) {
                    showNotification('没有保存的位置!', 'warning');
                    return;
                }
                for (let servo in positions) {
                    document.getElementById(servo).value = positions[servo];
                    updateServo(servo, positions[servo]);
                }
                showNotification('位置已加载!', 'success');
            })
            .catch(error => {
                showNotification('加载错误: ' + error, 'error');
            });
        }
        
        function showNotification(message, type) {
            const statusElement = document.getElementById('movement-status');
            const dotElement = document.getElementById('status-dot');
            
            statusElement.textContent = message;
            dotElement.style.background = {
                success: '#2ecc71',
                error: '#e74c3c',
                warning: '#f1c40f'
            }[type];
            
            setTimeout(() => {
                statusElement.textContent = '系统就绪';
                dotElement.style.background = '#2ecc71';
            }, 2000);
        }
        
        // 检查连接状态
        setInterval(() => {
            fetch('/status')
            .catch(() => {
                document.getElementById('connection-status').textContent = '连接断开';
                document.getElementById('connection-status').style.color = '#e74c3c';
            });
        }, 5000);
    </script>
</body>
</html>
)rawliteral";

// 在文件开头，其他全局变量之后添加
struct ServoStatus {
    float currentAngle;
    float targetAngle;
    bool isMoving;
    uint32_t lastUpdateTime;
    String lastError;
};

// 声明全局变量
ServoStatus servoStatus[SERVO_COUNT];

// 将S型曲线插值函数的实现移到moveServoSmooth函数之前
float sCurveInterpolation(float start, float end, float t) {
    float x = (t - 0.5) * 6.0;
    float sigmoid = 1.0 / (1.0 + exp(-x));
    return start + (end - start) * sigmoid;
}

// 添加错误日志宏
#define LOG_ERROR(msg, ...) \
    Serial.printf("错误 - %s: " msg "\n", SERVO_NAMES[servoIndex], ##__VA_ARGS__)

// 函数实现部分
void moveServoSmooth(uint8_t servoIndex, float targetAngle, float currentAngle) {
    // 在函数开始时更新状态
    currentMovingServo = SERVO_NAMES[servoIndex];
    servoStatus[servoIndex].isMoving = true;
    servoStatus[servoIndex].targetAngle = targetAngle;
    isMovingServos = true;
    
    // 安全检查
    if (SERVO_LIMITS[servoIndex].isStuck) {
        LOG_ERROR("处于保护状态");
        return;
    }
    
    // 获取舵机配置
    const ServoConfig& config = SERVO_CONFIGS[servoIndex];
    
    // 确保目标角度在安全范围内
    targetAngle = constrain(targetAngle, 
                          SERVO_LIMITS[servoIndex].minAngle,
                          SERVO_LIMITS[servoIndex].maxAngle);
    
    float angle = currentAngle;
    
    if (currentAngle < 0) {
        angle = 90.0;
    }
    
    // 计算总路程和方向
    float totalDistance = abs(targetAngle - angle);
    float direction = (targetAngle > angle) ? 1.0 : -1.0;
    
    // 初始化运动参数
    float currentSpeed = config.startSpeed;
    float currentAccel = config.acceleration;
    float distanceTraveled = 0.0;
    
    // 计算加速和减速点
    float accelDist = totalDistance * 0.35;
    float decelDist = totalDistance * 0.35;
    
    // 特别处理肩部舵机
    if (servoIndex == 3) {
        accelDist = totalDistance * 0.35;  // 缩短加速段
        decelDist = totalDistance * 0.35;  // 缩短减速段
        currentSpeed *= 0.9;               // 提高初始速度
        currentAccel *= 0.8;               // 提高加速度
    }
    
    // 根据移动距离动态调整超时时间
    float moveDistance = abs(targetAngle - currentAngle);
    uint32_t adjustedTimeout = MOVE_TIMEOUT;
    if(moveDistance > 90) {
        adjustedTimeout = MOVE_TIMEOUT * 1.5;  // 大角度移动给予更多时间
    }
    if(servoIndex == 3) { // 肩部舵机
        adjustedTimeout = SHOULDER_MOVE_TIMEOUT * (moveDistance / 90.0);  // 根据距离调整
    }
    
    // 监控移动是否卡死
    uint32_t moveStartTime = millis();
    uint32_t lastProgressTime = moveStartTime;
    float lastAngle = currentAngle;
    
    if (servoIndex == 0) {  // 手部舵机
        // 限制最大移动角度
        float maxAngleChange = 120.0;  // 限制最大移动角度
        if (abs(targetAngle - currentAngle) > maxAngleChange) {
            Serial.printf("手部舵机: 限制最大移动角度 %.1f -> %.1f\n", 
                abs(targetAngle - currentAngle), maxAngleChange);
            if (targetAngle > currentAngle) {
                targetAngle = currentAngle + maxAngleChange;
            } else {
                targetAngle = currentAngle - maxAngleChange;
            }
        }
        
        // 确保目标角度在有效范围内
        targetAngle = constrain(targetAngle, 10, 170);  // 留出安全余量
    }
    
    while (abs(angle - targetAngle) > 0.1) {
        if (shouldCancelMovement) {
            Serial.printf("舵机 %s 移动被取消\n", SERVO_NAMES[servoIndex]);
            shouldCancelMovement = false;  // 重置取消标志
            return;
        }
        
        // 改进卡死检测逻辑
        if (millis() - lastProgressTime > 1000) {
            if (abs(angle - lastAngle) < 0.1) {
                // 尝试轻微调整再次移动
                angle += (targetAngle > angle) ? 0.5 : -0.5;
                uint16_t pulseLen = angleToPWM(servoIndex, angle);
                if (pulseLen > 0) {
                    setPWMSafely(servoIndex, pulseLen);
                }
                
                // 如果持续无进展，才报告卡死
                if (millis() - lastProgressTime > 3000) {
                    LOG_ERROR("可能卡死 (当前角度: %.1f)", angle);
                    SERVO_LIMITS[servoIndex].isStuck = true;
                    return;
                }
            }
            lastProgressTime = millis();
            lastAngle = angle;
        }
        
        // 检查是否超时
        if (millis() - moveStartTime > adjustedTimeout) {
            LOG_ERROR("移动超时 (目标: %.1f, 当前: %.1f)", targetAngle, angle);
            return;
        }
        
        // 计算当前位置在总行程中的比例
        float progress = distanceTraveled / totalDistance;
        
        // 使用S型曲线调整速度
        float speedMultiplier = sCurveInterpolation(0.5, 1.0, progress);
        
        // 根据位置调整速度
        if (distanceTraveled < accelDist) {
            currentSpeed = min(currentSpeed + currentAccel, config.maxSpeed);
        } else if (distanceTraveled > (totalDistance - decelDist)) {
            currentSpeed = max(currentSpeed - currentAccel, config.startSpeed);
        }
        
        // 应用S型曲线
        float step = currentSpeed * direction * speedMultiplier;
        
        // 修改肩部舵机特殊处理
        if (servoIndex == 3) {
            if (abs(angle - targetAngle) < 10) {
                step *= 0.6;  // 减小减速幅度
            }
            if (totalDistance > 30) {
                step *= 0.8;  // 增加大角度移动时的速度
            }
        }
        
        // 为手部舵机添加特殊处理
        if (servoIndex == 0) {
            // 更严格的步长控制
            step = constrain(step, -1.0, 1.0);  // 限制最大步长
            
            // 接近目标时更加谨慎
            if (abs(angle - targetAngle) < 10) {
                step *= 0.5;  // 减小步长
            }
            
            // 防止累积误差
            static float lastAngle = angle;
            if (abs(angle - lastAngle) > 5.0) {
                Serial.println("手部舵机: 检测到异常角度变化，调整步长");
                step *= 0.3;
            }
            lastAngle = angle;
        }
        
        // 更新角度
        angle += step;
        angle = constrain(angle, config.min, config.max);
        
        // 设置PWM
        uint16_t pulseLen = angleToPWM(servoIndex, angle);
        if (pulseLen > 0) {
            if (!setPWMSafely(servoIndex, pulseLen)) {
                break;
            }
        }
        
        // 手部舵机的特殊延时处理
        if (servoIndex == 0) {
            float delayMultiplier = 1.0;
            if (abs(angle - targetAngle) < 20) {
                delayMultiplier = 1.2;  // 接近目标位置时稍微放慢
            }
            delay(static_cast<unsigned int>(config.stepDelay * delayMultiplier));
        } else {
            delay(config.stepDelay);
        }
        
        distanceTraveled = abs(angle - currentAngle);
        
        // 每次移动都更新时间戳
        servoStatus[servoIndex].lastUpdateTime = millis();
    }
    
    // 修改最后的微调
    if (!shouldCancelMovement) {
        if (servoIndex == 3) {
            delay(config.stepDelay * 2); // 减少额外等待时间
        }
        uint16_t pulseLen = angleToPWM(servoIndex, targetAngle);
        if (pulseLen > 0) {
            if (!setPWMSafely(servoIndex, pulseLen)) {
                return;
            }
        }
        delay(config.stepDelay);
    }
    
    // 移动完成后重置取消标志
    shouldCancelMovement = false;
    
    // 在函数结束时更新状态
    servoStatus[servoIndex].isMoving = false;
    servoStatus[servoIndex].currentAngle = targetAngle;
    servoStatus[servoIndex].lastUpdateTime = millis();
    currentMovingServo = "";
    isMovingServos = false;
}

// 添加舵机状态重置函数
void resetServoStatus(uint8_t servoIndex) {
    SERVO_LIMITS[servoIndex].isStuck = false;
    SERVO_LIMITS[servoIndex].lastPWM = -1;
}

// 修改handleServo函数
void handleServo() {
    if (!server.hasArg("name") || !server.hasArg("angle")) {
        server.send(400, "text/plain", "Missing parameters");
        return;
    }
    
    String servoName = server.arg("name");
    float angle = server.arg("angle").toFloat();
    
    // 获取舵机索引
    uint8_t servoIndex = 255; // 无效值
    if (servoName == "hand") servoIndex = 0;
    else if (servoName == "wrist") servoIndex = 1;
    else if (servoName == "elbow") servoIndex = 2;
    else if (servoName == "shoulder") servoIndex = 3;
    else if (servoName == "base") servoIndex = 4;
    
    if (servoIndex == 255) {
        server.send(400, "text/plain", "Invalid servo name");
        return;
    }
    
    // 安全检查
    if (SERVO_LIMITS[servoIndex].isStuck) {
        server.send(409, "text/plain", "Servo is protected");
        return;
    }
    
    // 获取当前角度
    float currentAngle = server.hasArg("current") ? 
                        server.arg("current").toFloat() : -1;
    
    // 使用安全的移动函数
    moveServoSmooth(servoIndex, angle, currentAngle);
    
    server.send(200, "text/plain", "OK");
}

// 添加保存位置的处理函数
void handleSavePositions() {
    if (!server.hasArg("plain")) {
        server.send(400, "text/plain", "No data received");
        return;
    }
    
    String positions = server.arg("plain");
    Serial.println("Received positions to save: " + positions);
    
    // 验证JSON格式
    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, positions);
    if (error) {
        Serial.println("Failed to parse JSON");
        server.send(400, "text/plain", "Invalid JSON format");
        return;
    }
    
    savePositionsToFlash(positions.c_str());
    server.send(200, "text/plain", "Positions saved");
}

// 添加位置计算辅助函数
struct ServoMove {
    uint8_t index;
    float distance;
    float targetAngle;
};

// 修改handleLoadPositions函数
void handleLoadPositions() {
    if (isMovingServos) {
        server.send(409, "text/plain", "System is busy");
        return;
    }
    
    String positions = loadPositionsFromFlash();
    Serial.println("Loaded positions: " + positions);
    
    if (positions == "{}") {
        server.send(404, "text/plain", "No saved positions found");
        return;
    }
    
    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, positions);
    
    if (error) {
        Serial.println("Failed to parse positions");
        server.send(400, "text/plain", "Invalid saved positions");
        return;
    }
    
    // 先发送响应
    server.send(200, "application/json", positions);
    
    isMovingServos = true;
    lastMoveTime = millis();
    
    // 创建一个动态分配的MoveData对象
    MoveData* moveData = new MoveData();
    
    // 获取当前位置和目标位置
    for (int i = 0; i < SERVO_COUNT; i++) {
        const char* servoNames[] = {"hand", "wrist", "elbow", "shoulder", "base"};
        moveData->targets[i] = doc[servoNames[i]].as<float>();
        // 获取当前位置（从PWM值反推角度）
        uint16_t currentPWM = pwm.getPWM(SERVO_PINS[i]);
        moveData->currents[i] = map(currentPWM, SERVOMIN, SERVOMAX, 0, 180);
    }
    
    // 使用任务来处理舵机移动
    xTaskCreate(
        [](void* parameter) {
            MoveData* data = (MoveData*)parameter;
            
            // 先移动除了肩部和底座以外的舵机
            for (int i = 0; i < SERVO_COUNT; i++) {
                if (i != 3 && i != 4) { // 不是肩部和底座
                    uint16_t targetPWM = angleToPWM(i, data->targets[i]);
                    pwm.setPWM(SERVO_PINS[i], 0, targetPWM);
                }
            }
            
            // 移动肩部舵机
            moveServoSmooth(3, data->targets[3], data->currents[3]);
            
            // 最后移动底座舵机
            uint16_t targetPWM = angleToPWM(4, data->targets[4]);
            pwm.setPWM(SERVO_PINS[4], 0, targetPWM);
            
            // 清理内存
            delete data;
            isMovingServos = false;
            vTaskDelete(NULL);
        },
        "servo_move",
        4096,
        moveData,
        1,
        NULL
    );
}

// 添加收缩位置的角度常量
const float RETRACT_ANGLES[] = {154, 74, 150, 30, 90}; // 手部->手腕->肘部->肩部->底座

// 将returnToCenter函数改名并修改为支持多种预设位置
void moveToPreset(bool isHome) {
    const uint8_t moveOrder[] = {0, 1, 2, 3, 4};
    
    // 获取所有舵机的当前位置
    float currentAngles[SERVO_COUNT];
    for(uint8_t i = 0; i < SERVO_COUNT; i++) {
        uint16_t currentPWM = pwm.getPWM(SERVO_PINS[i]);
        currentAngles[i] = map(currentPWM, SERVOMIN, SERVOMAX, 0, 180);
        // 确保获取的角度在有效范围内
        currentAngles[i] = constrain(currentAngles[i], 
            SERVO_CONFIGS[i].min, 
            SERVO_CONFIGS[i].max);
    }
    
    // 添加中间过渡点
    const float transitionAngles[] = {120, 90, 90, 60, 90}; // 相对安全的中间位置
    
    // 第一阶段：如果当前位置差异较大，先移动到过渡位置
    for(uint8_t i = 0; i < SERVO_COUNT; i++) {
        uint8_t servoIndex = moveOrder[i];
        float targetAngle = isHome ? 90.0 : RETRACT_ANGLES[servoIndex];
        
        // 如果当前位置与目标位置差异大于45度，使用过渡点
        if(abs(currentAngles[servoIndex] - targetAngle) > 45) {
            Serial.printf("移动%s到过渡位置...\n", SERVO_NAMES[servoIndex]);
            moveServoSmooth(servoIndex, transitionAngles[servoIndex], currentAngles[servoIndex]);
            delay(300); // 等待稳定
            currentAngles[servoIndex] = transitionAngles[servoIndex];
        }
    }
    
    // 第二阶段：移动到最终位置
    for(uint8_t i = 0; i < SERVO_COUNT; i++) {
        uint8_t servoIndex = moveOrder[i];
        float targetAngle = isHome ? 90.0 : RETRACT_ANGLES[servoIndex];
        
        Serial.printf("移动%s到%s位置...\n", 
            SERVO_NAMES[servoIndex], 
            isHome ? "初始" : "收缩");
        
        moveServoSmooth(servoIndex, targetAngle, currentAngles[servoIndex]);
        
        // 根据舵机类型和移动距离调整等待时间
        int delayTime = 200;
        if(servoIndex == 1) { // 手腕
            delayTime = 400;  // 增加手腕的等待时间
        } else if(servoIndex == 2 || servoIndex == 3) { // 肘部和肩部
            delayTime = 500;
        }
        delay(delayTime);
    }
}

// 修改handleCenter函数
void handleCenter() {
    String preset = server.hasArg("preset") ? server.arg("preset") : "home";
    moveToPreset(preset == "home");
    server.send(200, "text/plain", "OK");
}

// 添加根路径处理函数
void handleRoot() {
    server.send(200, "text/html", index_html);
}

// 添加取消移动的处理函数
void handleCancelMovement() {
    shouldCancelMovement = true;
    isMovingServos = false;
    server.send(200, "text/plain", "Movement cancelled");
    Serial.println("Movement cancelled by user");
}

// 添加舵机状态重置函数的路由处理
void handleResetServo() {
    if (!server.hasArg("name")) {
        server.send(400, "text/plain", "Missing servo name");
        return;
    }
    
    String servoName = server.arg("name");
    uint8_t servoIndex = 255;
    
    if (servoName == "hand") servoIndex = 0;
    else if (servoName == "wrist") servoIndex = 1;
    else if (servoName == "elbow") servoIndex = 2;
    else if (servoName == "shoulder") servoIndex = 3;
    else if (servoName == "base") servoIndex = 4;
    else if (servoName == "all") {
        clearErrors();
        server.send(200, "text/plain", "All servos reset");
        return;
    }
    
    if (servoIndex == 255) {
        server.send(400, "text/plain", "Invalid servo name");
        return;
    }
    
    resetServoStatus(servoIndex);
    server.send(200, "text/plain", "Servo reset");
}

// 添加错误状态清理函数
void clearErrors() {
    for(uint8_t i = 0; i < SERVO_COUNT; i++) {
        resetServoStatus(i);
    }
    shouldCancelMovement = false;
    isMovingServos = false;
    currentMovingServo = "";
    Serial.println("All errors cleared");
}

// 添加新的全局变量和数据结构
QueueHandle_t commandQueue;
const int QUEUE_SIZE = 10;
const char* SERVO_NAME_MAP[] = {"hand", "wrist", "elbow", "shoulder", "base"};

struct ServoCommand {
    uint8_t servoIndex;
    float targetAngle;
    bool isCompleted;
};

// 添加紧急停止功能
void handleEmergencyStop() {
    shouldCancelMovement = true;
    isMovingServos = false;
    
    // 清空命令队列
    xQueueReset(commandQueue);
    
    // 停止所有舵机
    for(uint8_t i = 0; i < SERVO_COUNT; i++) {
        servoStatus[i].isMoving = false;
        // 记录当前位置
        uint16_t currentPWM = pwm.getPWM(SERVO_PINS[i]);
        servoStatus[i].currentAngle = map(currentPWM, SERVOMIN, SERVOMAX, 0, 180);
    }
    
    Serial.println("紧急停止已执行!");
    server.send(200, "text/plain", "Emergency stop executed");
}

// 添加舵机校准功能
void calibrateServo(uint8_t servoIndex) {
    if (servoIndex >= SERVO_COUNT) return;
    
    Serial.printf("开始校准舵机 %s\n", SERVO_NAMES[servoIndex]);
    
    // 记录原始位置
    float originalAngle = servoStatus[servoIndex].currentAngle;
    
    // 测试最小角度
    moveServoSmooth(servoIndex, SERVO_LIMITS[servoIndex].minAngle, originalAngle);
    delay(1000);
    
    // 测试最大角度
    moveServoSmooth(servoIndex, SERVO_LIMITS[servoIndex].maxAngle, SERVO_LIMITS[servoIndex].minAngle);
    delay(1000);
    
    // 返回中间位置
    moveServoSmooth(servoIndex, 90, SERVO_LIMITS[servoIndex].maxAngle);
    
    Serial.printf("舵机 %s 校准完成\n", SERVO_NAMES[servoIndex]);
}

// 添加状态监控任务
void statusMonitorTask(void * parameter) {
    const unsigned long CHECK_INTERVAL = 500; // 增加到500ms检查一次
    TickType_t xLastWakeTime = xTaskGetTickCount();
    
    while(true) {
        for(uint8_t i = 0; i < SERVO_COUNT; i++) {
            if (servoStatus[i].isMoving) {
                unsigned long timeSinceLastUpdate = millis() - servoStatus[i].lastUpdateTime;
                unsigned long timeoutLimit = (i == 3) ? SHOULDER_MOVE_TIMEOUT : MOVE_TIMEOUT;
                
                // 检查是否超时
                if (timeSinceLastUpdate > timeoutLimit) {
                    Serial.printf("警告: 舵机 %s 移动时间较长 (%.1f秒)\n", 
                        SERVO_NAMES[i], timeSinceLastUpdate/1000.0);
                    
                    // 不立即停止，给出警告并继续尝试
                    if (timeSinceLastUpdate > timeoutLimit * 2) {
                        Serial.printf("错误: 舵机 %s 移动超时，正在重置\n", SERVO_NAMES[i]);
                        servoStatus[i].isMoving = false;
                        servoStatus[i].lastError = "Movement timeout";
                        resetServoStatus(i);
                    }
                }
            }
        }
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(CHECK_INTERVAL));
    }
}

// 添加内存监控宏定义
#define LOG_MEMORY_STATUS() \
    Serial.printf("内存状态 - 可用: %d bytes, 最大块: %d bytes, 最小空闲: %d bytes\n", \
        ESP.getFreeHeap(), ESP.getMaxAllocHeap(), ESP.getMinFreeHeap())

// 在setup函数中添加新的初始化代码
void setup() {
  Serial.begin(115200);
    Serial.println("\n=== 机械臂Web控制系统 ===");

    // 初始化SPIFFS
    if(!SPIFFS.begin(true)) {
        Serial.println("SPIFFS初始化失败!");
        return;
    }
    Serial.println("SPIFFS初始化成功");

    // 初始化WiFi AP
    WiFi.softAP(ssid, password);
    Serial.println("WiFi AP已启动");
    Serial.print("IP地址: ");
    Serial.println(WiFi.softAPIP());

    // 初始化I2C和PWM驱动
    Wire.begin(I2C_SDA, I2C_SCL, 100000);
  pwm.begin();
    pwm.setPWMFreq(SERVO_FREQ);

    // 设置Web服务器路由
    server.on("/", handleRoot);
    server.on("/servo", handleServo);
    server.on("/save", HTTP_POST, handleSavePositions);
    server.on("/load", HTTP_GET, handleLoadPositions);
    server.on("/center", handleCenter);
    server.on("/cancel", handleCancelMovement);
    server.on("/reset", handleResetServo);
    server.on("/status", handleStatus);
    server.on("/emergency", handleEmergencyStop);
    server.on("/calibrate", HTTP_POST, []() {
        if (!server.hasArg("servo")) {
            server.send(400, "text/plain", "Missing servo parameter");
            return;
        }
        String servoName = server.arg("servo");
        uint8_t servoIndex = 255;
        for(uint8_t i = 0; i < SERVO_COUNT; i++) {
            if(String(SERVO_NAME_MAP[i]) == servoName) {
                servoIndex = i;
                break;
            }
        }
        if(servoIndex == 255) {
            server.send(400, "text/plain", "Invalid servo name");
            return;
        }
        calibrateServo(servoIndex);
        server.send(200, "text/plain", "Calibration completed");
    });
    server.begin();
    Serial.println("HTTP服务器已启动");

    // 初始化所有舵机到中间位置
    for(uint8_t i = 0; i < SERVO_COUNT; i++) {
        uint16_t middlePos = angleToPWM(i, 90.0);  // 修改这里，传入舵机索引
        pwm.setPWM(SERVO_PINS[i], 0, middlePos);
        delay(100);
    }
    
    Serial.println("系统初始化完成!");

    // 创建命令队列
    commandQueue = xQueueCreate(QUEUE_SIZE, sizeof(ServoCommand));
    
    // 初始化舵机状态
    for(uint8_t i = 0; i < SERVO_COUNT; i++) {
        servoStatus[i].currentAngle = 90;
        servoStatus[i].targetAngle = 90;
        servoStatus[i].isMoving = false;
        servoStatus[i].lastUpdateTime = 0;
        servoStatus[i].lastError = "";
    }
    
    // 创建状态监控任务
    xTaskCreate(
        statusMonitorTask,
        "StatusMonitor",
        4096,
        NULL,
        1,
        NULL
    );
    
    // 添加内存检查
    Serial.printf("可用堆内存: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("最大分配堆块: %d bytes\n", ESP.getMaxAllocHeap());
    Serial.printf("最小空闲堆大小: %d bytes\n", ESP.getMinFreeHeap());
}

void loop() {
    static unsigned long lastMemCheck = 0;
    const unsigned long MEM_CHECK_INTERVAL = 30000; // 每30秒检查一次
    
    server.handleClient();
    
    // 检查移动是否超时
    if (isMovingServos && (millis() - lastMoveTime > MOVE_TIMEOUT)) {
        isMovingServos = false;
    }
    
    // 定期内存检查
    if (millis() - lastMemCheck > MEM_CHECK_INTERVAL) {
        LOG_MEMORY_STATUS();
        lastMemCheck = millis();
    }
}

void savePositionsToFlash(const char* positions) {
    if (SPIFFS.exists("/servo_positions.json")) {
        SPIFFS.remove("/servo_positions.json");  // 先删除旧文件
    }
    
    File file = SPIFFS.open("/servo_positions.json", "w");
    if(!file) {
        Serial.println("Failed to open file for writing");
        return;
    }
    
    if (file.print(positions)) {
        Serial.println("File written successfully");
    } else {
        Serial.println("Write failed");
    }
    file.close();
}

String loadPositionsFromFlash() {
    if(!SPIFFS.exists("/servo_positions.json")) {
        Serial.println("No saved positions found");
        return "{}";
    }
    
    File file = SPIFFS.open("/servo_positions.json", "r");
    if(!file) {
        Serial.println("Failed to open file for reading");
        return "{}";
    }
    
    String positions = file.readString();
    file.close();
    
    if(positions.length() == 0) {
        Serial.println("File is empty");
        return "{}";
    }
    
    return positions;
}

void handleStatus() {
    JsonDocument doc;
    doc["isMoving"] = isMovingServos;
    doc["currentServo"] = currentMovingServo;
    
    JsonObject servoStatus = doc["servos"].to<JsonObject>();
    for (uint8_t i = 0; i < SERVO_COUNT; i++) {
        JsonObject servo = servoStatus[SERVO_NAMES[i]].to<JsonObject>();
        servo["stuck"] = SERVO_LIMITS[i].isStuck;
        servo["lastMove"] = millis() - SERVO_LIMITS[i].lastMoveTime;
        servo["currentAngle"] = ::servoStatus[i].currentAngle;
        servo["targetAngle"] = ::servoStatus[i].targetAngle;
        servo["isMoving"] = ::servoStatus[i].isMoving;
        servo["lastError"] = ::servoStatus[i].lastError;
    }
    
    String response;
    serializeJson(doc, response);
    server.send(200, "application/json", response);
}
